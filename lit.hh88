# -*- coding: utf-8 -*-
import logging
import asyncio
import aiohttp
import os
import time
import traceback
import html
from datetime import datetime, timedelta
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.error import BadRequest, RetryAfter
from telegram.helpers import escape_markdown
from telegram.ext import ApplicationBuilder, ContextTypes, CommandHandler, CallbackQueryHandler, TypeHandler, ApplicationHandlerStop, MessageHandler, filters
from config import BOT_TOKEN, ADMIN_ID, LOG_GROUP_ID, ADMIN_GROUP_ID, MIN_BET, HOUSE_FEE_PERCENT, MIN_TIP, REQUIRED_CHANNEL_ID, REQUIRED_CHANNEL_LINK
from database import DatabaseManager
from wallet_manager import WalletManager
from fix_wallet_indices import fix_wallet_indices
from fairness import ProvablyFair
import random
import math
import re
from typing import Dict, Set, List

# Initialize logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO,
    handlers=[
        logging.FileHandler("log.log"),
        logging.StreamHandler()
    ]
)
# Reduce spam from libraries
logging.getLogger("httpx").setLevel(logging.WARNING)
logging.getLogger("telegram").setLevel(logging.WARNING)
logging.getLogger("apscheduler").setLevel(logging.WARNING)

logger = logging.getLogger(__name__)

# Spam Protection
user_spam_tracker = {}
BLOCKED_DURATION = 30
SPAM_THRESHOLD = 5
SPAM_TIME_WINDOW = 3

async def check_channel_membership(user_id, context):
    """Checks if user is a member of the required channel."""
    try:
        member = await context.bot.get_chat_member(chat_id=REQUIRED_CHANNEL_ID, user_id=user_id)
        if member.status in ['member', 'administrator', 'creator']:
            return True
        return False
    except Exception as e:
        logger.error(f"Error checking channel membership for {user_id}: {e}")
        # Fail open if bot is not admin or other error, to avoid blocking everyone if config is wrong
        # But for 'Force Join', usually fail closed. 
        # However, if bot can't see members, it crashes.
        # Let's assume bot is configured correctly.
        return False

async def channel_check_middleware(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Middleware to enforce channel membership."""
    if not update.effective_user or not update.effective_chat:
        return

    user_id = update.effective_user.id
    
    # Skip for admin or private chats if needed? No, enforce for everyone usually.
    if user_id == ADMIN_ID: return

    # Check if this is a callback query for verification
    if update.callback_query and update.callback_query.data == "verify_channel":
        return # Let the handler handle it

    # Check DB cache
    user_status = db.get_user_channel_status(user_id)
    # (channel_member, last_channel_check)
    
    is_member = False
    need_check = True
    
    if user_status:
        cached_member, last_check = user_status
        if cached_member and last_check:
            # Check if check is recent (e.g. 1 hour)
            last_check_dt = datetime.strptime(str(last_check), '%Y-%m-%d %H:%M:%S') if isinstance(last_check, str) else last_check
            # Handling timestamp string format from sqlite
            if (datetime.now() - last_check_dt).total_seconds() < 3600:
                is_member = True
                need_check = False

    if need_check:
        is_member = await check_channel_membership(user_id, context)
        db.update_channel_membership(user_id, is_member)

    if not is_member:
        # Stop processing and send Join prompt
        if update.message:
            keyboard = [
                [InlineKeyboardButton("Join Channel üì¢", url=REQUIRED_CHANNEL_LINK)],
                [InlineKeyboardButton("‚úÖ Confirm Membership", callback_data="verify_channel")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await update.message.reply_text(
                "‚õî **Access Denied**\n\nYou must join our channel to use this bot!",
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )
            raise ApplicationHandlerStop
        elif update.callback_query:
            await update.callback_query.answer("‚ö†Ô∏è You must join the channel first!", show_alert=True)
            raise ApplicationHandlerStop

async def verify_channel_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user_id = query.from_user.id
    
    is_member = await check_channel_membership(user_id, context)
    db.update_channel_membership(user_id, is_member)
    
    if is_member:
        await query.answer("‚úÖ Verified! You can now use the bot.", show_alert=True)
        await query.message.delete()
        # Optionally trigger /start or help
        await update.effective_message.reply_text("üéâ Welcome! Type /help to start.")
    else:
        await query.answer("‚ùå You haven't joined yet!", show_alert=True)

async def spam_check(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.effective_user:
        return
        
    user_id = update.effective_user.id
    current_time = time.time()
    
    if user_id not in user_spam_tracker:
        user_spam_tracker[user_id] = {'timestamps': [], 'blocked_until': 0}
        
    user_data = user_spam_tracker[user_id]
    
    # Check if blocked
    if current_time < user_data['blocked_until']:
        remaining = int(user_data['blocked_until'] - current_time)
        if remaining % 5 == 0: # Only notify occasionally or not at all to avoid more spam
             pass 
        raise ApplicationHandlerStop # Stop processing

    # Clean old timestamps
    user_data['timestamps'] = [t for t in user_data['timestamps'] if current_time - t < SPAM_TIME_WINDOW]
    
    # Add new timestamp
    user_data['timestamps'].append(current_time)
    
    # Check threshold
    if len(user_data['timestamps']) > SPAM_THRESHOLD:
        user_data['blocked_until'] = current_time + BLOCKED_DURATION
        user_data['timestamps'] = [] # Reset
        try:
            if update.effective_message:
                await update.effective_message.reply_text(f"‚õî You are sending messages too fast. Blocked for {BLOCKED_DURATION} seconds.")
        except Exception:
            pass
        raise ApplicationHandlerStop

# Initialize Managers
db = DatabaseManager()
# Wrap wallet manager in try-except in case dependencies are missing during dev
try:
    wallet = WalletManager()
except ImportError:
    logger.warning("Wallet dependencies missing. Wallet features will fail.")
    wallet = None

# Price Manager
class PriceManager:
    def __init__(self):
        self.prices = {'eth': 0.0, 'sol': 0.0, 'ltc': 0.0, 'usdt': 1.0, 'usdc': 1.0}
        self.last_updated = 0
        self.cache_duration = 600 # seconds (10 minutes)
        self.running = False

    async def start(self):
        self.running = True
        asyncio.create_task(self._update_loop())

    async def _update_loop(self):
        while self.running:
            await self.update_prices()
            await asyncio.sleep(60) # Check every minute

    async def update_prices(self):
        try:
            url = "https://api.coingecko.com/api/v3/simple/price?ids=ethereum,solana,litecoin,tether,usd-coin&vs_currencies=usd"
            async with aiohttp.ClientSession() as session:
                async with session.get(url, timeout=10) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        self.prices['eth'] = float(data.get('ethereum', {}).get('usd', 0))
                        self.prices['sol'] = float(data.get('solana', {}).get('usd', 0))
                        self.prices['ltc'] = float(data.get('litecoin', {}).get('usd', 0))
                        # BTC Removed
                        self.prices['usdt'] = float(data.get('tether', {}).get('usd', 1.0))
                        self.prices['usdc'] = float(data.get('usd-coin', {}).get('usd', 1.0))
                        self.last_updated = datetime.now().timestamp()
                        logger.info(f"Updated Prices: {self.prices}")
                        return True
                    else:
                        logger.error(f"Price fetch failed with status: {resp.status}")
        except Exception as e:
            logger.error(f"Price fetch error: {e}")
        return False

    def get_price(self, currency):
        # Return cached price immediately
        return self.prices.get(currency.lower(), 0.0)

    def get_usd_value(self, amount, currency):
        price = self.get_price(currency)
        return amount * price

    def get_crypto_amount(self, usd_amount, currency):
        price = self.get_price(currency)
        if price <= 0: return 0.0
        return usd_amount / price

price_manager = PriceManager()

# In-memory storage for active PvP games
# Format: {game_id: {'creator_id': int, 'amount': float, 'currency': str, 'choice': str}}
active_games = {}
active_blackjack_games = {}
active_mines_games = {}
active_drop = {'number': None, 'amount': 0.0, 'currency': None, 'active': False, 'chat_id': None}
active_chicken_games = {}
chicken_locks = set()
active_rain = {'active': False, 'end_time': 0, 'chat_id': None, 'winners': {}}
rob_cooldowns = {}
mines_locks = set()
coinflip_locks = set()
coinflip_seeds = {}
rps_locks = set()
pvp_locks = set()
game_counter = 0
MAINTENANCE_MODE = False
JULZ_MESSAGE_FILE = "julz_message.txt"

async def log_to_admin(context: ContextTypes.DEFAULT_TYPE, message: str):
    """Sends a log message to the admin group."""
    try:
        await context.bot.send_message(chat_id=LOG_GROUP_ID, text=f"üìã *Log Entry*\n\n{message}", parse_mode='Markdown')
        logger.info(message)
    except Exception as e:
        logger.error(f"Failed to send log to admin group: {e}")

def is_admin(update: Update):
    """Checks if the user is an admin or in the admin group."""
    user_id = update.effective_user.id
    chat_id = update.effective_chat.id
    
    if user_id == ADMIN_ID: return True
    if chat_id == ADMIN_GROUP_ID: return True
    return False

async def get_username(user_id, context, user=None):
    try:
        if user:
            chat = user
        else:
            chat = await context.bot.get_chat(user_id)
        
        def sanitize(text):
            if not text: return ""
            return text.replace('*', '').replace('_', '').replace('`', '').replace('[', '').replace(']', '')
        
        parts = []
        if chat.first_name:
            parts.append(sanitize(chat.first_name))
        if chat.last_name:
            parts.append(sanitize(chat.last_name))
            
        full_name = " ".join(parts).strip()
        username = f"@{sanitize(chat.username)}" if chat.username else ""
        
        if full_name and username:
            return f"{full_name} ({username})"
        elif full_name:
            return full_name
        elif username:
            return username
        else:
            return f"User:{user_id}"
    except:
        # Fallback to DB if API fails
        try:
            u = db.get_user(user_id)
            if u and u[1]:
                return f"@{u[1]} (ID:{user_id})"
        except:
            pass
        return f"User:{user_id}"

# Cooldown storage
last_deposit_check = {}
# Pending notifications cache: txid -> timestamp
notified_pending_txids = {}

async def background_deposit_check(context: ContextTypes.DEFAULT_TYPE):
    """Background job to check deposits for active users."""
    if not wallet: return
    
    # Clean up old pending notifications cache (older than 1 hour)
    now = time.time()
    to_remove = [k for k, v in notified_pending_txids.items() if now - v > 3600]
    for k in to_remove:
        del notified_pending_txids[k]
    
    # Smart Polling: Only check active users (last 2 hours)
    users = db.get_active_users(minutes=120)
    
    # Batch processing
    BATCH_SIZE = 5
    
    for i in range(0, len(users), BATCH_SIZE):
        batch = users[i:i+BATCH_SIZE]
        
        for u in batch:
            user_id = u[0]
            # u structure from get_active_users:
            # 0: user_id, 1: username, 2: sol, 3: eth, 4: ltc, 5: banned, 6: wallet_index
            # 7: usdt, 8: usdc, 9-13: last_wallet_balances...
            
            wallet_index = u[6]
            if not wallet_index: continue
            
            # Extract pre-fetched last balances to avoid extra DB calls
            last_bals = {
                'sol': u[9], 'eth': u[10], 'ltc': u[11], 
                'usdt': u[12], 'usdc': u[13]
            }

            try:
                # Reuse check_user_deposit logic
                # Pass wallet_index and last_bals to optimize
                result = await check_user_deposit(user_id, context, wallet_index=wallet_index, last_bals_cache=last_bals)
                
                # check_user_deposit returns a string if deposit found, else None
                if result:
                    if "Confirmed" in result or "Pending" in result:
                        # Notify user
                        try:
                            await context.bot.send_message(chat_id=user_id, text=result, parse_mode='Markdown')
                        except Exception:
                            pass # User blocked bot
                        
            except Exception as e:
                logger.error(f"Error in background check for {user_id}: {e}")
                
        # Sleep between batches to respect RPC limits
        await asyncio.sleep(2)

async def check_user_deposit(user_id, context, wallet_index=None, last_bals_cache=None):
    """Helper to check deposits for a specific user."""
    if not wallet: return "Wallet system unavailable."
    
    if wallet_index is None:
        user_row = db.get_user(user_id)
        if not user_row: return "User not found."
        # Fix: Access by name if possible, or correct index. 
        # database.py uses sqlite3.Row, so we can use names.
        try:
            wallet_index = user_row['wallet_index']
        except (IndexError, TypeError, ValueError):
             # Fallback to index if Row factory fails or manual tuple
             wallet_index = user_row[9] # Based on schema
    
    if not wallet_index: return "Wallet not initialized."

    currencies = ['eth', 'sol', 'ltc', 'usdt', 'usdc']
    
    # Get addresses
    eth_addr = wallet.get_address('eth', wallet_index) # Used for ETH, USDT, USDC
    sol_addr = wallet.get_address('sol', wallet_index)
    ltc_addr = wallet.get_address('ltc', wallet_index)
    
    addr_map = {
        'eth': eth_addr, 'usdt': eth_addr, 'usdc': eth_addr,
        'sol': sol_addr, 'ltc': ltc_addr
    }
    
    # Thresholds for detection
    thresholds = {
        'eth': 0.000001, 'sol': 0.000001, 'ltc': 0.000001, 
        'usdt': 0.01, 'usdc': 0.01
    }
    
    # Max deposit limit sanity check (e.g. 1 million)
    MAX_DEPOSIT_LIMIT = 1000000.0

    loop = asyncio.get_running_loop()
    msg = []
    
    async def check_single(curr):
        try:
            addr = addr_map[curr]
            
            if last_bals_cache and curr in last_bals_cache:
                last_bal = last_bals_cache[curr]
            else:
                last_bal = db.get_last_wallet_balance(user_id, curr)
            
            # Run blocking check_balance in executor
            real_bal = await loop.run_in_executor(None, wallet.check_balance, curr, addr)
            
            # Debug Log
            # if user_id == ADMIN_ID:
            #    logger.info(f"DEBUG {curr}: Real={real_bal}, Last={last_bal}, Addr={addr}")

            if real_bal is not None and real_bal > last_bal:
                diff = real_bal - last_bal
                
                # Sanity Check for Phantom Balances
                if diff > MAX_DEPOSIT_LIMIT:
                    logger.error(f"PHANTOM DEPOSIT DETECTED: User {user_id}, {diff} {curr}. Ignored.")
                    return None

                if diff > thresholds.get(curr, 0):
                    # Check Confirmations and TXID
                    try:
                        txid = await loop.run_in_executor(None, wallet.get_latest_txid, curr, addr)
                        
                        # Fix: Handle missing TXID gracefully
                        if not txid or txid == "N/A":
                             # Wait and retry? Or just log.
                             # If we can't get TXID, we can't verify uniqueness.
                             # We should NOT credit without TXID to prevent double crediting if loop runs again.
                             return None 
                        
                        # Check if already processed
                        if db.is_processed_txid(txid):
                            # Already handled, just update baseline if needed (should be done though)
                            db.update_last_wallet_balance(user_id, curr, real_bal)
                            return None

                        confs = await loop.run_in_executor(None, wallet.get_tx_confirmations, curr, txid)
                    except Exception as e:
                        print(f"Error checking confirmations for {curr}: {e}")
                        return None # Fail safe

                    if confs < 1:
                        # Prevent spamming "Pending" for the same TXID
                        if txid not in notified_pending_txids:
                            notified_pending_txids[txid] = time.time()
                            fmt_diff = f"{diff:.6f}"
                            return f"{curr.upper()}: Deposit detected (+{fmt_diff}) but pending ({confs}/1 confirmations)."
                        else:
                            return None # Already notified about this pending tx
                    
                    # Proceed with deposit
                    if db.add_processed_txid(txid, user_id, curr, diff):
                        db.update_balance(user_id, curr, diff)
                        db.update_last_wallet_balance(user_id, curr, real_bal)
                        
                        usd_val = price_manager.get_usd_value(diff, curr)
                        uname = await get_username(user_id, context)
                        
                        fmt_diff = f"{diff:.6f}"
                        log_msg = f"{curr.upper()}: +{fmt_diff} (${usd_val:.2f})"
                        
                        db.log_transaction(user_id, 'deposit', curr, diff, 'blockchain', f'Deposit detected. TXID: {txid}')
                        await log_to_admin(context, f"üíéüíéüíé **DEPOSIT CONFIRMED** üíéüíéüíé\n\nUser: {uname} ({user_id})\nAmount: +{fmt_diff} {curr.upper()} (${usd_val:.2f})\nTXID: `{txid}`")
                        return log_msg
            
            # Even if no deposit, update last active to keep checking this user
            # Actually, update_last_active should be on user interaction. 
            # Background check doesn't mean user is active.
            
            return None
        except Exception as e:
            logger.error(f"Error checking {curr}: {e}")
            return None

    # Run all checks in parallel
    results = await asyncio.gather(*[check_single(c) for c in currencies])
    
    for r in results:
        if r: msg.append(r)

    if msg:
        if any("+" in m and "pending" not in m for m in msg):
            return "üíé **Deposit Confirmed!**\n" + "\n".join(msg)
        else:
             return "‚è≥ **Deposits Pending:**\n" + "\n".join(msg)
    else:
        return "No new deposits found."

async def parse_bet_amount(update: Update, context: ContextTypes.DEFAULT_TYPE, amount_str: str, currency: str):
    """Helper to parse bet amount handling 'all', 'half', and numeric values."""
    user_id = update.effective_user.id
    currency = currency.lower()
    
    if currency not in ['eth', 'sol', 'ltc', 'usdt', 'usdc']:
        await update.message.reply_text("Invalid currency. Use eth, sol, ltc, usdt, or usdc.")
        return None, None, None

    balance = db.get_balance(user_id, currency)
    
    if amount_str.lower() == 'all':
        crypto_amount = balance
        usd_amount = price_manager.get_usd_value(crypto_amount, currency)
    elif amount_str.lower() == 'half':
        crypto_amount = balance / 2
        usd_amount = price_manager.get_usd_value(crypto_amount, currency)
    else:
        try:
            usd_amount = float(amount_str)
            if math.isnan(usd_amount) or math.isinf(usd_amount):
                raise ValueError("NaN or Inf")
            crypto_amount = price_manager.get_crypto_amount(usd_amount, currency)
        except ValueError:
            await update.message.reply_text("Invalid amount.")
            return None, None, None
            
    if crypto_amount <= 0:
        await update.message.reply_text("Amount must be positive.")
        return None, None, None
        
    if balance < crypto_amount:
         await update.message.reply_text(f"Insufficient balance. You have {balance:.6f} {currency.upper()} (${usd_amount:.2f}).")
         return None, None, None
         
    return crypto_amount, usd_amount, currency

async def check_deposit_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user_id = query.from_user.id
    
    # Cooldown check (30s)
    now = datetime.now().timestamp()
    if user_id in last_deposit_check:
        if now - last_deposit_check[user_id] < 30:
            await query.answer("‚è≥ Please wait 30 seconds between checks.", show_alert=True)
            return
            
    last_deposit_check[user_id] = now
    # await query.answer("Checking blockchain...", show_alert=False)
    
    result = await check_user_deposit(user_id, context)
    
    if "Confirmed" in result:
        await query.answer("Deposit Confirmed!", show_alert=False)
        await query.message.reply_text(result)
    else:
        # Just update the button text temporarily or send a small notification?
        # Alert is better for negative result to avoid spamming chat
        await query.answer(result, show_alert=True)
        
    # Update last active timestamp for smart polling
    db.update_last_active(user_id)

async def start_deposit_session_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user_id = query.from_user.id
    
    if not wallet:
        await query.answer("Wallet system unavailable.", show_alert=True)
        return

    await query.answer("Starting session...", show_alert=False)
    
    user_row = db.get_user(user_id)
    if not user_row:
        await query.message.reply_text("User not found.")
        return
        
    wallet_index = user_row[6]
    
    # Update baseline for all currencies
    currencies = ['eth', 'sol', 'ltc', 'usdt', 'usdc']
    loop = asyncio.get_running_loop()
    
    async def update_baseline(curr):
        try:
            addr = wallet.get_address(curr, wallet_index)
            # Run blocking check in executor
            real_bal = await loop.run_in_executor(None, wallet.check_balance, curr, addr)
            if real_bal is not None:
                # IMPORTANT: Do not blindly overwrite if the user already has pending deposits!
                # Fix: Check for deposit right here before resetting!
                last_bal = db.get_last_wallet_balance(user_id, curr)
                
                # If real_bal > last_bal, we might have a missed deposit.
                # However, "Start Session" is usually for *new* deposits.
                # If we detect a difference, we should probably credit it IF it hasn't been processed.
                # But here we just want to establish a baseline.
                # If last_bal is 0, we assume existing funds are irrelevant (user just joined or resyncing).
                # BUT if user just sent funds and then clicked Start, we screw them.
                
                # Compromise:
                # If real_bal > last_bal, check if we should credit it.
                if last_bal > 0 and real_bal > last_bal:
                     diff = real_bal - last_bal
                     if diff > 0.000001:
                         # Try to process it using standard logic (fetch txid, etc)
                         # This requires calling check_user_deposit logic, but we are inside a callback.
                         # Let's just NOT update the baseline to the higher amount, 
                         # so the next check_deposit call will catch it.
                         # We keep last_bal as is.
                         return

                # If real_bal < last_bal (spent funds elsewhere), we must sync down.
                # If last_bal == 0, we sync up (assuming pre-existing balance).
                # Wait, if last_bal == 0 and real_bal > 0, is it a deposit?
                # If the user has never used the bot (last_bal=0), we treat current balance as "Initial Balance" (not a deposit).
                # Otherwise people could import old wallets and get free credits.
                
                db.update_last_wallet_balance(user_id, curr, real_bal)
        except Exception as e:
            logger.error(f"Error updating baseline for {curr}: {e}")

    await asyncio.gather(*[update_baseline(c) for c in currencies])
    
    # Update last active
    db.update_last_active(user_id)
            
    await query.message.reply_text("üîµ **Deposit Session Started!**\n\nPlease send your funds now. After sending, click 'Check Deposits'.", parse_mode='Markdown')

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    
    # Check Maintenance
    if MAINTENANCE_MODE and not is_admin(update):
        await update.message.reply_text("üöß Bot is currently under maintenance. Please try again later.")
        return

    # Handle deep linking for PvP moves
    args = context.args
    if args and args[0].startswith('move_'):
        # Format: move_<game_id>
        try:
            game_id = int(args[0].split('_')[1])
            await pvp_show_move_options(update, context, game_id)
            return
        except (IndexError, ValueError):
            await update.message.reply_text("Invalid game link.")
            return

    if db.add_user(user.id, user.username):
        msg = (
            f"üîµ *Welcome to Rival, {user.first_name}!* üîµ\n\n"
            "üíé *The Ultimate Crypto Casino on Telegram*\n\n"
            "Here you can play games, bet with crypto, and win big! üí∏\n\n"
            "üéÆ *Available Games:*\n"
            "‚Ä¢ üÉè **Blackjack** - Hit or Stand to 21!\n"
            "‚Ä¢ üí£ **Mines** - Find gems, avoid bombs!\n"
            "‚Ä¢ üöÄ **Rocket** - Cashout before the crash!\n"
            "‚Ä¢ üêî **Chicken** - Cross the road for multipliers!\n"
            "‚Ä¢ üìà **Limbo** - High risk, high reward!\n"
            "‚Ä¢ ü™ô **Coinflip** - Double or nothing!\n"
            "‚Ä¢ ‚úÇÔ∏è **RPS** - Rock, Paper, Scissors (PvE & PvP)!\n\n"
            "üí∞ *Getting Started:*\n"
            "1. /deposit to add funds (ETH, SOL, LTC)\n"
            "2. /balance to check your wallet\n"
            "3. /help to see all commands\n\n"
            "‚öñÔ∏è *Fairness:*\n"
            "We use a **Provably Fair** system. Type /fairness to learn more.\n\n"
            "üçÄ *Good Luck!*"
        )
        await update.message.reply_text(msg, parse_mode='Markdown')
        uname = await get_username(user.id, context, user=user)
        await log_to_admin(context, f"New User Joined: {uname} (ID: {user.id})")
    else:
        msg = (
            f"üëã *Welcome back, {user.first_name}!* üëã\n\n"
            "Ready to win some crypto? üíé\n"
            "Use /help to see available games and commands."
        )
        await update.message.reply_text(msg, parse_mode='Markdown')

async def deposit(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user_data = db.get_user(user_id)
    if not user_data:
        await update.message.reply_text("Please /start first.")
        return

    wallet_index = user_data[6] # wallet_index column
    
    if wallet:
        eth_addr = wallet.get_address('eth', wallet_index)
        sol_addr = wallet.get_address('sol', wallet_index)
        ltc_addr = wallet.get_address('ltc', wallet_index)
        # btc_addr = wallet.get_address('btc', wallet_index) # BTC Removed
        
        msg = (
            "üí∞ *Your Deposit Addresses* üí∞\n"
            "_(Send any amount, detected automatically)_\n\n"
            f"*ETH/USDT/USDC:* `{eth_addr}`\n"
            f"*SOL:* `{sol_addr}`\n"
            f"*LTC:* `{ltc_addr}`\n\n"
            # f"*BTC:* `{btc_addr}`\n\n" # BTC Removed
            "‚ö†Ô∏è *Note:* Minimum deposit $1 worth of crypto.\n"
            "üëá *Start a session BEFORE sending funds to ensure accuracy!*"
        )
        
        keyboard = [
            [InlineKeyboardButton("Start Deposit Session üöÄ", callback_data="start_deposit_session")],
            [InlineKeyboardButton("Check Deposits üîÑ", callback_data="check_deposit")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await update.message.reply_text(msg, parse_mode='Markdown', reply_markup=reply_markup)
        
        # Trigger background check immediately for this user (optional optimization)
        # We'll just let the background job handle it to keep code clean
    else:
        await update.message.reply_text("Wallet system unavailable.")

async def balance(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user_data = db.get_user(user_id)
    if not user_data:
        await update.message.reply_text("Please /start first.")
        return

    # Trigger sync logic is now in background job, but we can do a quick check here too or just read DB
    # For responsiveness, we rely on DB which is updated by the job every 5s.
    
    # Use named access since we switched to sqlite3.Row
    eth_bal = user_data['balance_eth'] or 0.0
    sol_bal = user_data['balance_sol'] or 0.0
    ltc_bal = user_data['balance_ltc'] or 0.0
    usdt_bal = user_data['balance_usdt'] or 0.0
    usdc_bal = user_data['balance_usdc'] or 0.0
    
    eth_usd = price_manager.get_usd_value(eth_bal, 'eth')
    sol_usd = price_manager.get_usd_value(sol_bal, 'sol')
    ltc_usd = price_manager.get_usd_value(ltc_bal, 'ltc')
    # btc_usd = price_manager.get_usd_value(btc_bal, 'btc') # BTC Removed
    usdt_usd = price_manager.get_usd_value(usdt_bal, 'usdt')
    usdc_usd = price_manager.get_usd_value(usdc_bal, 'usdc')
    
    # Sanity check for display (prevent "phantom" huge balances from showing)
    def format_bal(bal, usd):
        if bal > 5000: # 1M cap for display sanity
            return "ERR", "ERR"
        return f"{bal:.6f}", f"${usd:.2f}"

    eth_str, eth_usd_str = format_bal(eth_bal, eth_usd)
    sol_str, sol_usd_str = format_bal(sol_bal, sol_usd)
    ltc_str, ltc_usd_str = format_bal(ltc_bal, ltc_usd)
    # btc_str, btc_usd_str = format_bal(btc_bal, btc_usd) # BTC Removed
    usdt_str, usdt_usd_str = format_bal(usdt_bal, usdt_usd)
    usdc_str, usdc_usd_str = format_bal(usdc_bal, usdc_usd)

    total_usd = eth_usd + sol_usd + ltc_usd + usdt_usd + usdc_usd
    if total_usd > 5000: # 1B cap
        total_usd_str = "ERR"
    else:
        total_usd_str = f"${total_usd:.2f}"

    msg = (
        "üè¶ *Your Balance* üè¶\n\n"
        f"üíé *Total Value:* {total_usd_str}\n\n"
        f"*ETH:* {eth_str} ({eth_usd_str})\n"
        f"*SOL:* {sol_str} ({sol_usd_str})\n"
        f"*LTC:* {ltc_str} ({ltc_usd_str})\n"
        f"*USDT:* {usdt_str} ({usdt_usd_str})\n"
        f"*USDC:* {usdc_str} ({usdc_usd_str})"
    )
    
    keyboard = [
        [InlineKeyboardButton("üì• Deposit", callback_data="deposit_btn"), InlineKeyboardButton("üì§ Withdraw", callback_data="withdraw_btn")],
        [InlineKeyboardButton("üîÑ Refresh", callback_data="refresh_balance")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    if update.callback_query:
        try:
            # Check if message is same to avoid error
            if update.callback_query.message.text_markdown == msg.replace('*', ''): # Very rough check, usually edit_message_text handles "message is not modified"
                 pass
            
            await update.callback_query.edit_message_text(msg, parse_mode='Markdown', reply_markup=reply_markup)
            await update.callback_query.answer("Balance updated!")
        except Exception:
             # Message content same or other error
             try:
                 await update.callback_query.answer()
             except:
                 pass
    else:
        await update.message.reply_text(msg, parse_mode='Markdown', reply_markup=reply_markup)

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = (
        "üîµ *Rival Help* üîµ\n\n"
        "‚ú® *How to Play:*\n"
        "‚Ä¢ All bets are placed in USD value, converted to crypto automatically.\n"
        "‚Ä¢ Winnings are paid out immediately to your balance.\n\n"
        "üéÆ *Games:*\n"
        "‚Ä¢ `/blackjack <amount> <currency>` - Play Blackjack (2x Payout).\n"
        "‚Ä¢ `/mines <amount> <currency> <count>` - Minesweeper (Multipliers!).\n"
        "‚Ä¢ `/dice <amount> <currency> [target]` - Roll the Dice (1-95)!\n"
        "‚Ä¢ `/slots <amount> <currency>` - Spin the Slots!\n"
        "‚Ä¢ `/roulette <amount> <currency> <bet>` - Classic Roulette!\n"
        "‚Ä¢ `/plinko <amount> <currency> [risk] [rows]` - Plinko Drop!\n"
        "‚Ä¢ `/towers <amount> <currency> [difficulty]` - Climb the Towers!\n"
        "‚Ä¢ `/connect4 <amount> <currency>` - PvP Connect 4!\n"
        "‚Ä¢ `/rocket` - Join the Rocket game (Crash)!\n"
        "‚Ä¢ `/chicken <amount> <currency>` - Cross the road safely!\n"
        "‚Ä¢ `/limbo <amount> <currency> <target>` - Win up to 1000x!\n"
        "‚Ä¢ `/limbo_high <amount> <currency>` - High Risk Limbo (Fixed 100x)!\n"
        "‚Ä¢ `/coinflip <amount> <currency>` - Classic 50/50 chance.\n"
        "‚Ä¢ `/rps <amount> <currency>` - Play against the bot.\n"
        "‚Ä¢ `/pvp <amount> <currency>` - Challenge other players (Blackjack)!\n\n"
        "‚öñÔ∏è *Fairness:*\n"
        "‚Ä¢ `/fairness` - Verify game fairness and seeds.\n\n"
        "üÜò *Support:*\n"
        "‚Ä¢ `/support <message>` - Send a message to admins.\n\n"
        "üéÅ *Rewards:*\n"
        "‚Ä¢ `/rakeback` - Claim your 5% rakeback on all wagers.\n"
        "‚Ä¢ `/wager` - View your total lifetime wagered amount.\n\n"
        "üí≥ *Wallet Commands:*\n"
        "‚Ä¢ `/deposit` - Get your deposit addresses (ETH, SOL, LTC, USDT, USDC).\n"
        "‚Ä¢ `/withdraw <currency> <amount> <address>` - Cash out your winnings.\n"
        "‚Ä¢ `/balance` - View your crypto and USD balance.\n"
        "‚Ä¢ `/tip <user_id> <amount> <currency>` - Tip another user.\n"
        "  (Or reply to their message with `/tip <amount> <currency>`)\n\n"
        "üëÆ *Admin:*\n"
        "‚Ä¢ `/admin` - Open Admin Panel.\n\n"
        "üöë *Support:*\n"
        "‚Ä¢ `/emotionalsupport` - Feeling down? Get help here!\n"
        "‚Ä¢ Contact: @temp0420"
    )
    
    # Add buttons for games (User request: "button to get into games")
    # We can't pre-fill user input, so we provide quick info or navigation
    keyboard = [
        [
            InlineKeyboardButton("üÉè Blackjack", callback_data="help_game:blackjack"),
            InlineKeyboardButton("üí£ Mines", callback_data="help_game:mines")
        ],
        [
            InlineKeyboardButton("üé≤ Dice", callback_data="help_game:dice"),
            InlineKeyboardButton("üé∞ Slots", callback_data="help_game:slots")
        ],
        [
            InlineKeyboardButton("üé° Roulette", callback_data="help_game:roulette"),
            InlineKeyboardButton("üìâ Plinko", callback_data="help_game:plinko")
        ],
        [
            InlineKeyboardButton("üóº Towers", callback_data="help_game:towers"),
            InlineKeyboardButton("üî¥ Connect 4", callback_data="help_game:connect4")
        ],
        [
            InlineKeyboardButton("üìà Limbo", callback_data="help_game:limbo"),
            InlineKeyboardButton("ü™ô Coinflip", callback_data="help_game:coinflip")
        ],
        [
            InlineKeyboardButton("‚úÇÔ∏è RPS", callback_data="help_game:rps"),
            InlineKeyboardButton("‚öîÔ∏è PvP", callback_data="help_game:pvp")
        ],
        [
            InlineKeyboardButton("üêî Chicken", callback_data="help_game:chicken"),
            InlineKeyboardButton("üöÄ Rocket", callback_data="help_game:rocket")
        ],
        [
             InlineKeyboardButton("üéÅ Claim Rakeback", callback_data="help_action:rakeback")
        ]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(msg, parse_mode='Markdown', reply_markup=reply_markup)

async def help_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    data = query.data
    
    if data.startswith("help_game:"):
        game = data.split(":")[1]
        help_texts = {
            "blackjack": "üÉè **Blackjack**\n\nTry to get 21 without busting!\nUsage: `/blackjack 10 sol`",
            "mines": "üí£ **Mines**\n\nReveal gems, avoid mines. More gems = higher multiplier!\nUsage: `/mines 5 eth 3` (3 mines)",
            "dice": "üé≤ **Dice**\n\nRoll the dice and beat the target!\nUsage: `/dice 10 ltc 50` (Target > 50)",
            "slots": "üé∞ **Slots**\n\nSpin the reels! Match symbols to win big.\nUsage: `/slots 5 sol`",
            "roulette": "üé° **Roulette**\n\nBet on Red, Black, Green, or Numbers!\nUsage: `/roulette 10 eth red`",
            "plinko": "üìâ **Plinko**\n\nDrop the ball through the pegs!\nUsage: `/plinko 10 usdt med 16` (Risk: low/med/high, Rows: 8-16)",
            "towers": "üóº **Towers**\n\nClimb the tower levels for higher multipliers!\nUsage: `/towers 5 ltc easy` (Difficulty: easy/med/hard)",
            "connect4": "üî¥ **Connect 4 (PvP)**\n\nPlay Connect 4 against another player!\nUsage: `/connect4 20 sol`",
            "limbo": "üìà **Limbo**\n\nPredict the multiplier crash point!\nNormal: `/limbo 10 ltc 2.0` (Target 2x)\nHigh Risk: `/limbo_high 10 ltc` (Target 100x)",
            "coinflip": "ü™ô **Coinflip**\n\nDouble or nothing on a coin toss.\nUsage: `/coinflip 20 sol`",
            "rps": "‚úÇÔ∏è **Rock Paper Scissors**\n\nBeat the bot!\nUsage: `/rps 15 eth`",
            "pvp": "‚öîÔ∏è **PvP**\n\nCreate a lobby and fight a real player!\nUsage: `/pvp 50 ltc`",
            "chicken": "üêî **Chicken Crossing**\n\nCross the road to multiply your bet!\nPress **Move** to advance (1.44x per step) or **Cashout**.\nUsage: `/chicken 10 sol`",
            "rocket": "üöÄ **Rocket Crash**\n\nAdmin starts the game. Bet before takeoff!\nWatch the multiplier rise and cash out before it crashes!\nUsage: `/bet <amount> <currency>` (when active)"
        }
        text = help_texts.get(game, "Unknown game.") # Get help text
        await query.message.reply_text(text, parse_mode='Markdown')
        
    elif data == "help_action:rakeback":
        await rakeback_command(update, context)
    
    elif data == "deposit_btn":
        await deposit(update, context)
        
    elif data == "withdraw_btn":
        await update.callback_query.message.reply_text("To withdraw, use: `/withdraw <currency> <amount> <address>`", parse_mode='Markdown')
        
    elif data == "refresh_balance":
        await balance(update, context)

async def withdraw(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # /withdraw <currency> <amount_usd> <address>
    user_id = update.effective_user.id
    args = context.args
    if len(args) != 3:
        await update.message.reply_text("Usage: /withdraw <currency> <amount_usd> <address>")
        return

    currency, amount_str, address = args[0].lower(), args[1], args[2]
    try:
        amount_usd = float(amount_str)
        if math.isnan(amount_usd) or math.isinf(amount_usd):
            raise ValueError("NaN/Inf")
    except ValueError:
        await update.message.reply_text("Invalid amount.")
        return

    if amount_usd < 1.0:
        await update.message.reply_text("Minimum withdrawal is $1.00 USD.")
        return

    valid_currencies = ['eth', 'sol', 'ltc', 'usdt', 'usdc']
    if currency not in valid_currencies:
        await update.message.reply_text("Invalid currency. Use eth, sol, ltc, usdt, or usdc.")
        return
    
    crypto_amount = price_manager.get_crypto_amount(amount_usd, currency)
    if crypto_amount <= 0:
        await update.message.reply_text("Error calculating crypto amount. Try again.")
        return

    current_bal = db.get_balance(user_id, currency)
    if current_bal < crypto_amount:
        await update.message.reply_text(f"Insufficient balance. You need {crypto_amount:.6f} {currency.upper()} (${amount_usd}).")
        return

    # Process withdrawal request
    # 1. Deduct from DB (lock funds)
    if db.update_balance(user_id, currency, -crypto_amount):
        # 2. Create DB entry
        req_id = db.create_withdrawal_request(user_id, currency, crypto_amount, address)
        
        # 3. Notify User
        await update.message.reply_text(f"üîµ **Withdrawal Request #{req_id} Submitted!**\nAmount: ${amount_usd} ({crypto_amount:.6f} {currency.upper()})\nStatus: Pending Approval")
        
        # 4. Notify Admin (DM)
        keyboard = [
            [
                InlineKeyboardButton("Approve ‚úÖ", callback_data=f"withdraw:approve:{req_id}"),
                InlineKeyboardButton("Deny ‚ùå", callback_data=f"withdraw:deny:{req_id}")
            ]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        try:
            uname = await get_username(user_id, context)
            # Escape for Markdown
            safe_uname = escape_markdown(uname, version=1)
            safe_address = escape_markdown(address, version=1)
            
            msg_text = (
                f"‚ö†Ô∏è *New Withdrawal Request* ‚ö†Ô∏è\n\n"
                f"User: {safe_uname} ({user_id})\n"
                f"USD Value: ${amount_usd}\n"
                f"Crypto: {crypto_amount:.6f} {currency.upper()}\n"
                f"Address: `{safe_address}`\n"
                f"Request ID: {req_id}"
            )

            # Send to DM
            await context.bot.send_message(
                chat_id=ADMIN_ID,
                text=msg_text,
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )

            # Send to Group
            if LOG_GROUP_ID:
                await context.bot.send_message(
                    chat_id=LOG_GROUP_ID,
                    text=msg_text,
                    reply_markup=reply_markup,
                    parse_mode='Markdown'
                )

        except Exception as e:
            logger.error(f"Failed to notify admin of withdrawal: {e}")
            await log_to_admin(context, f"Withdrawal Request #{req_id} created but failed to send button msg (Check logs).")
    else:
        await update.message.reply_text("Error processing withdrawal.")

async def withdraw_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    if not is_admin(update):
        await query.answer("‚õî Access Denied", show_alert=True)
        return
    
    # Format: withdraw:action:req_id
    data = query.data.split(':')
    action = data[1]
    req_id = int(data[2])
    
    req = db.get_withdrawal(req_id)
    if not req:
        await query.edit_message_text("Request not found.")
        return
    
    # req: (id, user_id, currency, amount, address, status, created_at)
    user_id, currency, amount, address, status = req[1], req[2], req[3], req[4], req[5]
    
    if status != 'pending':
        await query.edit_message_text(f"Request #{req_id} already {status}.")
        return

    if action == 'approve':
        # Prompt admin to confirm with TXID/Note
        await query.edit_message_text(
            f"‚ö†Ô∏è <b>Approval Step</b> ‚ö†Ô∏è\n\n"
            f"To finalize Request #{req_id}, copy and send:\n"
            f"<code>/confirm_withdraw {req_id} &lt;TXID&gt; &lt;NOTE&gt;</code>\n\n"
            f"Example:\n<code>/confirm_withdraw {req_id} 0x123...456 Payment Sent</code>",
            parse_mode='HTML'
        )
        
    elif action == 'deny':
        db.update_withdrawal_status(req_id, 'denied')
        # Refund
        db.update_balance(user_id, currency, amount)
        await query.edit_message_text(f"‚ùå **Request #{req_id} DENIED.** Funds refunded.")
        # Notify user
        try:
            await context.bot.send_message(chat_id=user_id, text=f"‚ùå **Your withdrawal of {amount} {currency} was denied.** Funds refunded.")
        except:
            pass

async def confirm_withdraw_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # /confirm_withdraw <req_id> <txid> <note...>
    user_id = update.effective_user.id
    if not is_admin(update): return

    args = context.args
    if len(args) < 3:
        await update.message.reply_text("Usage: /confirm_withdraw <req_id> <txid> <note>")
        return

    try:
        req_id = int(args[0])
        txid = args[1]
        note = " ".join(args[2:])
    except ValueError:
        await update.message.reply_text("Invalid Request ID.")
        return

    req = db.get_withdrawal(req_id)
    if not req:
        await update.message.reply_text("Request not found.")
        return

    # req: (id, user_id, currency, amount, address, status, created_at, txid, note)
    # Check status
    if req[5] != 'pending':
        await update.message.reply_text(f"Request #{req_id} is already {req[5]}.")
        return

    user_id_target = req[1]
    currency = req[2]
    amount = req[3]
    address = req[4]

    # Update DB
    db.update_withdrawal_status(req_id, 'approved', txid, note)
    
    await update.message.reply_text(f"üîµ **Request #{req_id} Approved & Saved.**")
    
    # Notify User
    try:
        safe_address = escape_markdown(address, version=1)
        safe_txid = escape_markdown(txid, version=1)
        safe_note = escape_markdown(note, version=1)
        
        msg = (
            f"üíé **Withdrawal Approved!**\n\n"
            f"Amount: {amount} {currency.upper()}\n"
            f"Address: `{safe_address}`\n\n"
            f"üÜî **TXID:** `{safe_txid}`\n"
            f"üìù **Note:** {safe_note}"
        )
        await context.bot.send_message(chat_id=user_id_target, text=msg, parse_mode='Markdown')
    except Exception as e:
        await update.message.reply_text(f"Approved, but failed to notify user: {e}")

async def rakeback_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    
    # Determine message object depending on context (Command vs Callback)
    if update.callback_query:
        message = update.callback_query.message
        # Answer callback to stop loading animation if not already done
        # (It might be done in router, but safe to do here if called directly)
        try:
            await update.callback_query.answer()
        except:
            pass
    else:
        message = update.message

    claimed = db.claim_rakeback(user_id)
    
    if not claimed:
        # Check if they have any wagered stats
        stats = db.get_wager_stats(user_id)
        # stats: wagered_usd, rb_sol, rb_eth, rb_ltc
        if stats:
            wagered = stats[0]
            await message.reply_text(f"No rakeback available.\nTotal Wagered: ${wagered:.2f}")
        else:
            await message.reply_text("No rakeback available.")
        return

    msg = "üíé **Rakeback Claimed!** üíé\n\n"
    if claimed.get('sol', 0) > 0:
        msg += f"SOL: +{claimed['sol']:.6f}\n"
    if claimed.get('eth', 0) > 0:
        msg += f"ETH: +{claimed['eth']:.6f}\n"
    if claimed.get('ltc', 0) > 0:
        msg += f"LTC: +{claimed['ltc']:.6f}\n"
        
    await message.reply_text(msg, parse_mode='Markdown')

async def wager_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    
    if update.callback_query:
        message = update.callback_query.message
    else:
        message = update.message

    stats = db.get_wager_stats(user_id)
    # stats: wagered_usd, rb_sol, rb_eth, rb_ltc
    if not stats:
        await message.reply_text("You haven't wagered anything yet.")
        return
        
    wagered_usd = stats[0]
    await message.reply_text(f"üé∞ **Total Wagered:** ${wagered_usd:.2f}", parse_mode='Markdown')

async def limbo_high_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # /limbo_high <amount> <currency>
    # Defaults to 100x target
    user_id = update.effective_user.id
    args = context.args
    
    if len(args) != 2:
        await update.message.reply_text("Usage: /limbo_high <amount|all|half> <currency>\n(Target is fixed at 100x for High Risk mode!)")
        return

    crypto_amount, amount_usd, currency = await parse_bet_amount(update, context, args[0], args[1])
    if crypto_amount is None: return

    multiplier = 100.0
    
    await play_limbo(update, context, amount_usd, crypto_amount, currency, multiplier, mode="High Risk")

async def play_limbo(update, context, amount_usd, crypto_amount, currency, multiplier, mode="Normal"):
    user_id = update.effective_user.id
    
    if not db.update_balance(user_id, currency, -crypto_amount):
        await update.message.reply_text("Error processing bet (Insufficient Balance).")
        return

    # Check Rakeback Eligibility (Anti-Advantage Play)
    # Disable rakeback for low multipliers (1.0x - 1.1x)
    rb_eligible = not (1.0 <= multiplier <= 1.1)
    
    # ADD WAGER
    db.add_wager(user_id, currency, crypto_amount, amount_usd, rakeback_eligible=rb_eligible)

    win_chance = 95.0 / multiplier
    roll = random.uniform(0, 100)
    actual_x = 95.0 / roll if roll > 0.001 else 99999.0
    
    uname = await get_username(user_id, context)
    
    title = "Limbo Result" if mode == "Normal" else "üî• HIGH RISK LIMBO üî•"
    
    if roll < win_chance:
        winnings = crypto_amount * multiplier
        db.update_balance(user_id, currency, winnings)
        usd_win = amount_usd * multiplier
        await update.message.reply_text(f"üé≤ **{title}** üé≤\n\nTarget: {multiplier}x\nActual X: {actual_x:.2f}x\nResult: WIN! üíé\nProfit: +${usd_win - amount_usd:.2f} ({winnings - crypto_amount:.6f} {currency.upper()})", parse_mode='Markdown')
        await log_to_admin(context, f"Limbo ({mode}): {uname} ({user_id}) WON {winnings:.6f} {currency} (x{multiplier})")
    else:
        db.update_house_balance(currency, crypto_amount)
        await update.message.reply_text(f"üé≤ **{title}** üé≤\n\nTarget: {multiplier}x\nActual X: {actual_x:.2f}x\nResult: Bust üí•\nLost: ${amount_usd:.2f}", parse_mode='Markdown')
        await log_to_admin(context, f"Limbo ({mode}): {uname} ({user_id}) LOST {crypto_amount:.6f} {currency} (x{multiplier})")


async def coinflip_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # /coinflip <amount_usd> <currency>
    user_id = update.effective_user.id
    args = context.args
    
    if len(args) != 2:
        await update.message.reply_text("Usage: /coinflip <amount_usd|all|half> <currency>")
        return

    crypto_amount, amount_usd, currency = await parse_bet_amount(update, context, args[0], args[1])
    if crypto_amount is None: return

    # Store crypto amount in callback with sufficient precision
    c_amt_str = f"{crypto_amount:.8f}"
    
    # Provably Fair Setup
    server_seed = ProvablyFair.generate_server_seed()
    public_hash = ProvablyFair.get_hash(server_seed)
    client_seed = ProvablyFair.generate_client_seed() # Random for now
    
    coinflip_seeds[user_id] = {
        'server_seed': server_seed,
        'client_seed': client_seed,
        'hash': public_hash
    }

    keyboard = [
        [
            InlineKeyboardButton("Heads ü™ô", callback_data=f"cf:{c_amt_str}:{currency}:heads"),
            InlineKeyboardButton("Tails ü¶Ö", callback_data=f"cf:{c_amt_str}:{currency}:tails")
        ]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    msg_text = (
        f"ü™ô **Coinflip**\n"
        f"Bet: ${amount_usd} ({crypto_amount:.6f} {currency.upper()})\n\n"
        f"üõ°Ô∏è **Provably Fair:**\n"
        f"Hash: `{public_hash}`\n\n"
        f"Choose Heads or Tails!"
    )
    
    await update.message.reply_text(msg_text, reply_markup=reply_markup, parse_mode='Markdown')

async def coinflip_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user = query.from_user
    
    if user.id in coinflip_locks:
        try:
            await query.answer("Please wait...", show_alert=False)
        except: pass
        return
        
    coinflip_locks.add(user.id)
    try:
        try:
            await query.answer()
        except BadRequest:
            pass

        data = query.data.split(':')
        # Format: cf:amount:currency:choice
        if len(data) != 4:
            return

        amount = float(data[1])
        currency = data[2]
        choice = data[3]
        
        # Calculate USD for display
        usd_val = price_manager.get_usd_value(amount, currency)

        if db.get_balance(user.id, currency) < amount:
            await query.message.reply_text("Insufficient balance.")
            return

        if not db.update_balance(user.id, currency, -amount):
            await query.message.reply_text("Error processing bet.")
            return

        # Add Wager
        # Disable rakeback for coinflip as requested
        db.add_wager(user.id, currency, amount, usd_val, rakeback_eligible=False)

        # Provably Fair Outcome
        if user.id in coinflip_seeds:
            seed_data = coinflip_seeds[user.id]
            server_seed = seed_data['server_seed']
            client_seed = seed_data['client_seed']
            # Nonce 1
            result_float = ProvablyFair.calculate_result(server_seed, client_seed, 1)
            outcome = 'heads' if result_float < 0.5 else 'tails'
            del coinflip_seeds[user.id]
        else:
            # Fallback if seed lost (restart bot?)
            outcome = random.choice(['heads', 'tails'])
            server_seed = "Unknown"
            client_seed = "Unknown"
            result_float = 0.0
        
        if choice == outcome:
            winnings = amount * 2
            db.update_balance(user.id, currency, winnings)
            msg_text = (
                f"ü™ô **Result: {outcome.upper()}!**\n"
                f"üíé **You WON ${usd_val*2:.2f}** ({winnings:.6f} {currency})!\n\n"
                f"üõ°Ô∏è **Fairness Check:**\n"
                f"Server Seed: `{server_seed}`\n"
                f"Client Seed: `{client_seed}`\n"
                f"Result: `{result_float:.5f}` (< 0.5 = Heads)"
            )
            uname = await get_username(user.id, context)
            await log_to_admin(context, f"Coinflip: {uname} ({user.id}) WON {amount:.6f} {currency} (${usd_val:.2f})")
        else:
            db.update_house_balance(currency, amount)
            msg_text = (
                f"ü™ô **Result: {outcome.upper()}**\n"
                f"‚ùå You lost ${usd_val:.2f} ({amount:.6f} {currency}).\n\n"
                f"üõ°Ô∏è **Fairness Check:**\n"
                f"Server Seed: `{server_seed}`\n"
                f"Client Seed: `{client_seed}`\n"
                f"Result: `{result_float:.5f}` (< 0.5 = Heads)"
            )
            uname = await get_username(user.id, context)
            await log_to_admin(context, f"Coinflip: {uname} ({user.id}) LOST {amount:.6f} {currency} (${usd_val:.2f})")

        try:
            await query.edit_message_text(msg_text, parse_mode='Markdown')
        except BadRequest as e:
            if "Message is not modified" not in str(e):
                logger.error(f"Error editing coinflip message: {e}")
                
    finally:
        if user.id in coinflip_locks:
            coinflip_locks.remove(user.id)

async def rps_pve(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # /rps <amount_usd> <currency>
    user_id = update.effective_user.id
    args = context.args
    
    if len(args) != 2:
        await update.message.reply_text("Usage: /rps <amount_usd|all|half> <currency>")
        return

    crypto_amount, amount_usd, currency = await parse_bet_amount(update, context, args[0], args[1])
    if crypto_amount is None: return

    c_amt_str = f"{crypto_amount:.8f}"

    # Send buttons
    keyboard = [
        [
            InlineKeyboardButton("Rock ü™®", callback_data=f"rps:{c_amt_str}:{currency}:rock"),
            InlineKeyboardButton("Paper üìÑ", callback_data=f"rps:{c_amt_str}:{currency}:paper"),
            InlineKeyboardButton("Scissors ‚úÇÔ∏è", callback_data=f"rps:{c_amt_str}:{currency}:scissors"),
        ]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(f"RPS: Choose your move for ${amount_usd} ({crypto_amount:.6f} {currency.upper()}):", reply_markup=reply_markup)

async def rps_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user = query.from_user
    
    if user.id in rps_locks:
        try: await query.answer("Please wait...", show_alert=False)
        except: pass
        return
    rps_locks.add(user.id)
    try:
        try: await query.answer()
        except: pass

        data = query.data.split(':')
        # Format: rps:amount:currency:choice
        if len(data) != 4:
            return

        amount = float(data[1])
        currency = data[2]
        choice = data[3]
        
        usd_val = price_manager.get_usd_value(amount, currency)

        # Re-check balance
        if db.get_balance(user.id, currency) < amount:
            await query.message.reply_text("Insufficient balance to play.")
            return

        # Deduct bet
        if not db.update_balance(user.id, currency, -amount):
            await query.message.reply_text("Error deducting balance.")
            return

        # Add Wager
        db.add_wager(user.id, currency, amount, usd_val)

        # Play logic
        bot_choice = random.choice(['rock', 'paper', 'scissors'])
        
        if choice == bot_choice:
            result = 'tie'
        elif (choice == 'rock' and bot_choice == 'scissors') or \
             (choice == 'scissors' and bot_choice == 'paper') or \
             (choice == 'paper' and bot_choice == 'rock'):
            result = 'win'
        else:
            result = 'lose'

        msg_text = ""
        if result == 'tie':
            db.update_balance(user.id, currency, amount) # Refund
            msg_text = f"Bot chose {bot_choice}. It's a tie! Bet returned."
        elif result == 'win':
            winnings = amount * 2
            db.update_balance(user.id, currency, winnings)
            msg_text = f"Bot chose {bot_choice}. üíé **You WON ${usd_val*2:.2f}** ({winnings:.6f} {currency})!"
            uname = await get_username(user.id, context)
            await log_to_admin(context, f"RPS PvE: {uname} ({user.id}) WON {amount} {currency}")
        else:
            db.update_house_balance(currency, amount)
            msg_text = f"Bot chose {bot_choice}. You LOST ${usd_val:.2f} ({amount:.6f} {currency})."
            uname = await get_username(user.id, context)
            await log_to_admin(context, f"RPS PvE: {uname} ({user.id}) LOST {amount} {currency}")

        # Edit message to show result and remove buttons
        try:
            await query.edit_message_text(text=f"{msg_text}")
        except BadRequest as e:
            if "Message is not modified" not in str(e):
                logger.error(f"Error editing rps message: {e}")
    finally:
        if user.id in rps_locks:
            rps_locks.remove(user.id)

# Admin Commands
async def admin_ban(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_admin(update):
        return

    try:
        target_id = int(context.args[0])
        db.set_ban_status(target_id, True)
        await update.message.reply_text(f"User {target_id} banned.")
    except (IndexError, ValueError):
        await update.message.reply_text("Usage: /ban <user_id>")

async def admin_unban(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_admin(update):
        return

    try:
        target_id = int(context.args[0])
        db.set_ban_status(target_id, False)
        await update.message.reply_text(f"User {target_id} unbanned.")
    except (IndexError, ValueError):
        await update.message.reply_text("Usage: /unban <user_id>")

async def admin_add_balance(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_admin(update):
        return

    try:
        target_id = int(context.args[0])
        currency = context.args[1].lower()
        amount = float(context.args[2])
        if math.isnan(amount) or math.isinf(amount):
             raise ValueError("NaN/Inf")
        
        db.update_balance(target_id, currency, amount)
        
        # Log it
        uname = await get_username(target_id, context)
        db.log_transaction(target_id, 'admin_add', currency, amount, 'admin', 'Admin added balance')
        await log_to_admin(context, f"Admin: Added {amount} {currency} to {uname} ({target_id})")
        
        await update.message.reply_text(f"Added {amount} {currency} to user {target_id}.")
        
        # Notify User
        try:
            usd_val = price_manager.get_usd_value(amount, currency)
            await context.bot.send_message(chat_id=target_id, text=f"üéÅ **Balance Added!**\n\nAdmin added {amount} {currency.upper()} (${usd_val:.2f}) to your balance!", parse_mode='Markdown')
        except:
            pass
            
    except (IndexError, ValueError):
        await update.message.reply_text("Usage: /add_bal <user_id> <currency> <amount>")

async def global_bonus_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_admin(update): return

    try:
        amount_usd = float(context.args[0])
        currency = context.args[1].lower()
    except (IndexError, ValueError):
        await update.message.reply_text("Usage: /global_bonus <amount_usd> <currency>\nExample: /global_bonus 5 ltc")
        return

    if amount_usd <= 0:
        await update.message.reply_text("Amount must be positive.")
        return

    if currency not in ['eth', 'sol', 'ltc']:
        await update.message.reply_text("Invalid currency.")
        return

    crypto_amount = price_manager.get_crypto_amount(amount_usd, currency)
    if crypto_amount <= 0:
        await update.message.reply_text("Price data unavailable.")
        return

    users = db.get_all_users()
    count = 0
    await update.message.reply_text(f"üéÅ Sending ${amount_usd} ({crypto_amount:.6f} {currency.upper()}) to {len(users)} users...")

    for user_row in users:
        uid = user_row[0]
        if db.update_balance(uid, currency, crypto_amount):
            count += 1
            db.log_transaction(uid, 'bonus', currency, crypto_amount, 'admin', 'Global Bonus')
            try:
                await context.bot.send_message(chat_id=uid, text=f"üéÅ **GLOBAL BONUS!** üéÅ\n\nYou received ${amount_usd} ({crypto_amount:.6f} {currency.upper()})!", parse_mode='Markdown')
            except:
                pass
        
        if count % 20 == 0:
            await asyncio.sleep(1)

    await update.message.reply_text(f"‚úÖ Bonus sent to {count} users.")

async def admin_remove_balance(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_admin(update):
        return

    try:
        target_id = int(context.args[0])
        currency = context.args[1].lower()
        amount = float(context.args[2])
        db.update_balance(target_id, currency, -amount)
        
        # Log it
        uname = await get_username(target_id, context)
        db.log_transaction(target_id, 'admin_remove', currency, -amount, 'admin', 'Admin removed balance')
        await log_to_admin(context, f"Admin: Removed {amount} {currency} from {uname} ({target_id})")

        await update.message.reply_text(f"Removed {amount} {currency} from user {target_id}.")
    except (IndexError, ValueError):
        await update.message.reply_text("Usage: /remove_bal <user_id> <currency> <amount>")

async def house_balance(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_admin(update):
        return

    balances = db.get_house_balances()
    msg = "üè† *House Balance* üè†\n\n"
    for key, val in balances.items():
        if key.startswith('house_'):
            curr = key.split('_')[1].upper()
            msg += f"*{curr}:* {val:.4f}\n"
    await update.message.reply_text(msg, parse_mode='Markdown')

# Fairness Command
async def fairness_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = (
        "‚öñÔ∏è *Provably Fair System* ‚öñÔ∏è\n\n"
        "This bot uses a **Provably Fair** system to ensure that all game outcomes are completely random and cannot be manipulated.\n\n"
        "üîπ *How it works:*\n"
        "1. Before each game round, the server generates a random **Server Seed**.\n"
        "2. This seed is hashed using SHA256 and shown to you as the **Public Hash** *before* you play.\n"
        "3. You provide a **Client Seed** (or one is automatically generated for you).\n"
        "4. The game result is calculated using `HMAC_SHA256(server_seed, client_seed + nonce)`.\n"
        "5. After the game, the **Server Seed** is revealed so you can verify the hash and the result.\n\n"
        "üîπ *Verification:*\n"
        "You can use any online HMAC SHA256 calculator or our open-source verification script to check your results.\n\n"
        "üõ°Ô∏è *Your Guarantee:*\n"
        "Because we commit to the Server Seed *before* you play, we cannot change the outcome after your bet is placed.\n"
    )
    await update.message.reply_text(msg, parse_mode='Markdown')

# Support Command
async def support_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    args = context.args
    
    if not args:
        await update.message.reply_text(
            "‚ùì *Usage:* `/support <message>`\n"
            "Example: `/support I found a bug in blackjack!`",
            parse_mode='Markdown'
        )
        return

    message = ' '.join(args)
    
    # Send to admin group
    try:
        sent_msg = await context.bot.send_message(
            chat_id=ADMIN_GROUP_ID,
            text=f"üÜò *Support Request*\n"
                 f"üë§ User: {user.full_name} (`{user.id}`)\n"
                 f"üìù Message:\n{message}",
            parse_mode='Markdown'
        )
        await update.message.reply_text(
            "‚úÖ *Message Sent!* An admin will reply shortly.",
            parse_mode='Markdown'
        )
    except Exception as e:
        logger.error(f"Failed to send support message: {e}")
        await update.message.reply_text("‚ùå Failed to send message. Please try again later.")

# Admin Reply Handler
async def admin_reply_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # Only process messages in the admin group that are replies
    if update.effective_chat.id != int(ADMIN_GROUP_ID):
        return

    if not update.message.reply_to_message:
        return

    original_msg = update.message.reply_to_message
    
    # Check if the original message is a support request
    if "Support Request" not in original_msg.text:
        return

    # Extract user ID
    try:
        # Regex to find user ID in format: (ID) or (`ID`)
        match = re.search(r'\((\d+)\)', original_msg.text) or re.search(r'\(`(\d+)`\)', original_msg.text)
        if match:
            user_id = int(match.group(1))
            reply_text = update.message.text
            
            await context.bot.send_message(
                chat_id=user_id,
                text=f"üë®‚Äçüíª *Admin Reply:*\n{reply_text}",
                parse_mode='Markdown'
            )
            await update.message.reply_text("‚úÖ Reply sent to user.")
        else:
            await update.message.reply_text("‚ùå Could not extract User ID.")
        
    except Exception as e:
        logger.error(f"Failed to reply to user: {e}")
        await update.message.reply_text("‚ùå Failed to parse user ID or send reply.")

# PvP Logic
async def pvp_create(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # /pvp <amount_usd> <currency>
    global game_counter
    user_id = update.effective_user.id
    
    if len(context.args) != 2:
        await update.message.reply_text("Usage: /pvp <amount_usd> <currency>")
        return

    try:
        amount_usd = float(context.args[0])
        currency = context.args[1].lower()
    except ValueError:
        await update.message.reply_text("Invalid amount.")
        return
    
    if amount_usd <= 0:
        await update.message.reply_text("Amount must be positive.")
        return

    if currency not in ['eth', 'sol', 'ltc']:
        await update.message.reply_text("Invalid currency.")
        return

    crypto_amount = price_manager.get_crypto_amount(amount_usd, currency)
    if crypto_amount <= 0:
        await update.message.reply_text("Price data unavailable.")
        return

    if db.get_balance(user_id, currency) < crypto_amount:
        await update.message.reply_text(f"Insufficient balance. You need {crypto_amount:.6f} {currency.upper()}.")
        return

    # Deduct balance immediately
    if db.update_balance(user_id, currency, -crypto_amount):
        # Add Wager
        db.add_wager(user_id, currency, crypto_amount, amount_usd)
        
        uname = await get_username(user_id, context)
        game_id = game_counter
        active_games[game_id] = {
            'amount': crypto_amount,
            'usd_value': amount_usd, # Store USD value for display consistency
            'currency': currency,
            'status': 'waiting',
            'players': {
                user_id: {'name': uname, 'choice': None}
            },
            'chat_id': update.effective_chat.id,
            'message_id': None # To be set after sending message
        }
        game_counter += 1
        
        keyboard = [
            [InlineKeyboardButton("Join Game üéÆ", callback_data=f"join:{game_id}")],
            [InlineKeyboardButton("Cancel ‚ùå", callback_data=f"cancel_pvp:{game_id}")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        msg = await update.message.reply_text(
            f"‚öîÔ∏è PvP Game #{game_id} created!\n"
            f"Bet: ${amount_usd} ({crypto_amount:.6f} {currency.upper()})\n"
            f"Player 1: {uname}\n"
            f"Waiting for opponent...",
            reply_markup=reply_markup
        )
        active_games[game_id]['message_id'] = msg.message_id
    else:
        await update.message.reply_text("Error creating game.")

async def pvp_join_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user = query.from_user
    try: await query.answer()
    except: pass

    data = query.data.split(':')
    # Format: join:game_id
    try:
        game_id = int(data[1])
    except (IndexError, ValueError):
        return

    if game_id in pvp_locks:
        try: await query.answer("Game is busy, try again.", show_alert=True)
        except: pass
        return

    pvp_locks.add(game_id)
    try:
        game = active_games.get(game_id)
        if not game or game['status'] != 'waiting':
            await query.answer("Game not available.", show_alert=True)
            return

        if len(game['players']) >= 2:
            await query.answer("Game is full.", show_alert=True)
            return

        # Check if user already joined
        if user.id in game['players']:
            await query.answer("You are already in this game.", show_alert=True)
            return

        # Check balance
        amount = game['amount']
        currency = game['currency']
        usd_val = game.get('usd_value', 0)
        
        if db.get_balance(user.id, currency) < amount:
            await query.answer("Insufficient balance.", show_alert=True)
            return

        # Deduct balance
        if not db.update_balance(user.id, currency, -amount):
            await query.answer("Error processing bet.", show_alert=True)
            return

        # Add Wager
        db.add_wager(user.id, currency, amount, usd_val)

        # Add player
        uname = await get_username(user.id, context)
        game['players'][user.id] = {'name': uname, 'choice': None}
        game['status'] = 'playing'

        # Update group message
        bot_username = context.bot.username or "RivalBot" # Fallback if username not set yet
        try:
            me = await context.bot.get_me()
            bot_username = me.username
        except Exception:
            pass

        move_url = f"https://t.me/{bot_username}?start=move_{game_id}"
        
        keyboard = [
            [InlineKeyboardButton("Make Your Move üé≤", url=move_url)]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        p1_name = list(game['players'].values())[0]['name']
        p2_name = uname
        
        try:
            await context.bot.edit_message_text(
                chat_id=game['chat_id'],
                message_id=game['message_id'],
                text=f"‚öîÔ∏è **PvP Game #{game_id} Started!**\n"
                     f"{p1_name} vs {p2_name}\n"
                     f"Bet: ${usd_val} ({amount:.6f} {currency.upper()})\n\n"
                     f"‚ö†Ô∏è Click below to choose Rock, Paper, or Scissors in DM!",
                reply_markup=reply_markup
            )
        except BadRequest as e:
            logger.error(f"Error starting PvP game: {e}")
            
    finally:
        if game_id in pvp_locks:
            pvp_locks.remove(game_id)

async def pvp_show_move_options(update: Update, context: ContextTypes.DEFAULT_TYPE, game_id: int):
    # Called from /start move_<game_id> in PM
    user = update.effective_user
    game = active_games.get(game_id)
    
    if not game:
        await update.message.reply_text("Game not found.")
        return
    
    if user.id not in game['players']:
        await update.message.reply_text("You are not part of this game.")
        return
    
    if game['players'][user.id]['choice']:
        await update.message.reply_text("You have already made your move.")
        return

    keyboard = [
        [
            InlineKeyboardButton("Rock ü™®", callback_data=f"move:{game_id}:rock"),
            InlineKeyboardButton("Paper üìÑ", callback_data=f"move:{game_id}:paper"),
            InlineKeyboardButton("Scissors ‚úÇÔ∏è", callback_data=f"move:{game_id}:scissors"),
        ]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(f"Game #{game_id}: Choose your move:", reply_markup=reply_markup)

async def pvp_move_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user = query.from_user
    try: await query.answer()
    except: pass
    
    data = query.data.split(':')
    # Format: move:game_id:choice
    try:
        game_id = int(data[1])
        choice = data[2]
    except (IndexError, ValueError):
        return

    if game_id in pvp_locks:
        try: await query.answer("Please wait...", show_alert=True)
        except: pass
        return

    pvp_locks.add(game_id)
    try:
        game = active_games.get(game_id)
        if not game:
            try: await query.edit_message_text("Game finished or not found.")
            except: pass
            return

        if user.id not in game['players']:
            return

        if game['players'][user.id]['choice']:
            await query.answer("You already chose.", show_alert=True)
            return

        # Record choice
        game['players'][user.id]['choice'] = choice
        try:
            await query.edit_message_text(f"You chose {choice}. Waiting for opponent...")
        except BadRequest:
            pass

        # Check if both players chose
        players = list(game['players'].values())
        ids = list(game['players'].keys())
        
        if all(p['choice'] for p in players):
            # Resolve game
            p1_id, p2_id = ids[0], ids[1]
            p1_choice = game['players'][p1_id]['choice']
            p2_choice = game['players'][p2_id]['choice']
            p1_name = game['players'][p1_id]['name']
            p2_name = game['players'][p2_id]['name']
            
            amount = game['amount']
            currency = game['currency']
            
            # Logic
            winner_id = None
            if p1_choice == p2_choice:
                result = 'tie'
            elif (p1_choice == 'rock' and p2_choice == 'scissors') or \
                 (p1_choice == 'scissors' and p2_choice == 'paper') or \
                 (p1_choice == 'paper' and p2_choice == 'rock'):
                winner_id = p1_id
                result = 'p1'
            else:
                winner_id = p2_id
                result = 'p2'

            # Payout
            total_pot = amount * 2
            house_fee = total_pot * (HOUSE_FEE_PERCENT / 100)
            payout = total_pot - house_fee
            
            usd_payout = price_manager.get_usd_value(payout, currency)

            msg_text = f"üèÅ **Game #{game_id} Result** üèÅ\n\n" \
                       f"{p1_name}: {p1_choice}\n" \
                       f"{p2_name}: {p2_choice}\n\n"

            if result == 'tie':
                db.update_balance(p1_id, currency, amount)
                db.update_balance(p2_id, currency, amount)
                msg_text += "It's a TIE! Bets returned."
            else:
                db.update_balance(winner_id, currency, payout)
                db.update_house_balance(currency, house_fee)
                winner_name = p1_name if result == 'p1' else p2_name
                msg_text += f"üèÜ **{winner_name} WINS!** (+{payout:.6f} {currency} / ${usd_payout:.2f})"
                
                # Log PvP result
                loser_id = p2_id if result == 'p1' else p1_id
                loser_name = p2_name if result == 'p1' else p1_name
                await log_to_admin(context, f"PvP Game #{game_id}: {winner_name} ({winner_id}) WON {payout:.6f} {currency} vs {loser_name} ({loser_id})")

            # Announce in group
            await context.bot.send_message(chat_id=game['chat_id'], text=msg_text, parse_mode='Markdown')
            
            # Cleanup
            del active_games[game_id]
            
    finally:
        if game_id in pvp_locks:
            pvp_locks.remove(game_id)

async def pvp_cancel_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user = query.from_user
    try: await query.answer()
    except: pass
    
    data = query.data.split(':')
    # Format: cancel_pvp:game_id
    try:
        game_id = int(data[1])
    except (IndexError, ValueError):
        return

    if game_id in pvp_locks:
        try: await query.answer("Please wait...", show_alert=True)
        except: pass
        return

    pvp_locks.add(game_id)
    try:
        game = active_games.get(game_id)
        if not game:
            try: await query.edit_message_text("Game not found or already cancelled.")
            except: pass
            return

        # Check if user is creator
        creator_id = list(game['players'].keys())[0]
        if user.id != creator_id:
            try: await query.answer("Only the creator can cancel this game.", show_alert=True)
            except: pass
            return
            
        if game['status'] != 'waiting':
             try: await query.answer("Game already started.", show_alert=True)
             except: pass
             return

        # Refund
        amount = game['amount']
        currency = game['currency']
        
        db.update_balance(creator_id, currency, amount)
        # Log refund? Maybe not necessary for cancel, but good for tracking.
        # We can just rely on update_balance.
        
        try:
            await query.edit_message_text(f"‚úÖ Game #{game_id} Cancelled. Funds refunded.")
        except BadRequest:
            pass
            
        del active_games[game_id]
        
    finally:
        if game_id in pvp_locks:
            pvp_locks.remove(game_id)

# --- PvP Blackjack ---
active_pvp_bj_games = {}
pvp_bj_locks = set()

async def pvp_bj_create(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # /blackjack_pvp <amount_usd> <currency>
    global game_counter
    user_id = update.effective_user.id
    
    if not context.args or len(context.args) != 2:
        await update.message.reply_text("Usage: /pvp_bj <amount_usd> <currency>")
        return

    try:
        amount_usd = float(context.args[0])
        currency = context.args[1].lower()
    except ValueError:
        await update.message.reply_text("Invalid amount.")
        return
    
    if amount_usd <= 0:
        await update.message.reply_text("Amount must be positive.")
        return

    if currency not in ['eth', 'sol', 'ltc', 'usdt', 'usdc']:
        await update.message.reply_text("Invalid currency. Use eth, sol, or ltc.")
        return

    crypto_amount = price_manager.get_crypto_amount(amount_usd, currency)
    if crypto_amount <= 0:
        await update.message.reply_text("Price data unavailable.")
        return

    if db.get_balance(user_id, currency) < crypto_amount:
        await update.message.reply_text(f"Insufficient balance. You need {crypto_amount:.6f} {currency.upper()}.")
        return

    if db.update_balance(user_id, currency, -crypto_amount):
        db.add_wager(user_id, currency, crypto_amount, amount_usd)
        
        uname = await get_username(user_id, context)
        game_id = game_counter
        game_counter += 1
        
        active_pvp_bj_games[game_id] = {
            'creator_id': user_id,
            'creator_name': uname,
            'opponent_id': None,
            'opponent_name': None,
            'amount': crypto_amount,
            'usd_amount': amount_usd,
            'currency': currency,
            'status': 'waiting',
            'deck': [],
            'creator_hand': [],
            'opponent_hand': [],
            'turn': None,
            'chat_id': update.effective_chat.id,
            'message_id': None
        }
        
        keyboard = [
            [InlineKeyboardButton("Join PvP Blackjack üÉè", callback_data=f"pvp_bj:join:{game_id}")],
            [InlineKeyboardButton("Cancel ‚ùå", callback_data=f"pvp_bj:cancel:{game_id}")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        msg = await update.message.reply_text(
            f"üÉè **PvP Blackjack #{game_id}**\n"
            f"Bet: ${amount_usd} ({crypto_amount:.6f} {currency.upper()})\n"
            f"Player 1: {uname}\n"
            f"Waiting for opponent...",
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
        active_pvp_bj_games[game_id]['message_id'] = msg.message_id
    else:
        await update.message.reply_text("Error creating game.")

async def pvp_bj_join_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user = query.from_user
    try: await query.answer()
    except: pass
    
    data = query.data.split(':')
    try: game_id = int(data[2])
    except: return

    if game_id in pvp_bj_locks:
        try: await query.answer("Please wait...", show_alert=True)
        except: pass
        return
        
    pvp_bj_locks.add(game_id)
    try:
        game = active_pvp_bj_games.get(game_id)
        if not game or game['status'] != 'waiting':
            await query.answer("Game not available.", show_alert=True)
            return
            
        if user.id == game['creator_id']:
            await query.answer("You cannot play against yourself.", show_alert=True)
            return
            
        crypto_amount = game['amount']
        currency = game['currency']
        
        if db.get_balance(user.id, currency) < crypto_amount:
            await query.answer(f"Insufficient balance.", show_alert=True)
            return
            
        if db.update_balance(user.id, currency, -crypto_amount):
            db.add_wager(user.id, currency, crypto_amount, game['usd_amount'])
            
            uname = await get_username(user.id, context)
            game['opponent_id'] = user.id
            game['opponent_name'] = uname
            game['status'] = 'playing'
            
            deck = create_deck()
            game['deck'] = deck
            game['creator_hand'] = [deck.pop(), deck.pop()]
            game['opponent_hand'] = [deck.pop(), deck.pop()]
            game['turn'] = game['creator_id']
            
            await update_pvp_bj_message(update, context, game_id)
        else:
            await query.answer("Error joining game.", show_alert=True)
    finally:
        if game_id in pvp_bj_locks: pvp_bj_locks.remove(game_id)

async def update_pvp_bj_message(update: Update, context: ContextTypes.DEFAULT_TYPE, game_id):
    game = active_pvp_bj_games.get(game_id)
    if not game: return
    
    c_hand = game['creator_hand']
    o_hand = game['opponent_hand']
    c_score = calculate_hand(c_hand)
    o_score = calculate_hand(o_hand)
    
    status_text = ""
    keyboard = []
    
    if game['status'] == 'finished':
        status_text = "\nüèÅ **Game Over** üèÅ"
        winner_id = None
        result = 'tie'
        reason = ""
        
        if c_score > 21 and o_score > 21:
            reason = "Both busted!"
            result = 'tie'
        elif c_score > 21:
            winner_id = game['opponent_id']
            reason = f"{game['creator_name']} busted!"
            result = 'opponent'
        elif o_score > 21:
            winner_id = game['creator_id']
            reason = f"{game['opponent_name']} busted!"
            result = 'creator'
        elif c_score > o_score:
            winner_id = game['creator_id']
            reason = f"{game['creator_name']} wins!"
            result = 'creator'
        elif o_score > c_score:
            winner_id = game['opponent_id']
            reason = f"{game['opponent_name']} wins!"
            result = 'opponent'
        else:
            reason = "Scores equal!"
            result = 'tie'
            
        total_pot = game['amount'] * 2
        house_fee = total_pot * (HOUSE_FEE_PERCENT / 100)
        payout = total_pot - house_fee
        
        if result == 'tie':
            db.update_balance(game['creator_id'], game['currency'], game['amount'])
            db.update_balance(game['opponent_id'], game['currency'], game['amount'])
            status_text += f"\nü§ù **It's a TIE!**\n{reason}\nFunds returned."
        else:
            db.update_balance(winner_id, game['currency'], payout)
            db.update_house_balance(game['currency'], house_fee)
            winner_name = game['creator_name'] if result == 'creator' else game['opponent_name']
            status_text += f"\nüèÜ **{winner_name} WINS!**\n{reason}\nWon {payout:.6f} {game['currency'].upper()}"
            
            try:
                await log_to_admin(context, f"PvP BJ #{game_id}: {winner_name} won {payout:.6f} {game['currency']} ({reason})")
            except: pass
            
        del active_pvp_bj_games[game_id]
        
    else:
        current_player_id = game['turn']
        current_player_name = game['creator_name'] if current_player_id == game['creator_id'] else game['opponent_name']
        status_text = f"\nüé≤ **Turn:** {current_player_name}"
        keyboard = [
            [InlineKeyboardButton("üëä Hit", callback_data=f"pvp_bj:hit:{game_id}"),
             InlineKeyboardButton("‚úã Stand", callback_data=f"pvp_bj:stand:{game_id}")]
        ]

    msg = (
        f"üÉè **PvP Blackjack #{game_id}**\n"
        f"Bet: ${game['usd_amount']} ({game['amount']:.6f} {game['currency'].upper()})\n\n"
        f"üë§ **{game['creator_name']}:** {format_hand(c_hand)} ({c_score})\n"
        f"üë§ **{game['opponent_name']}:** {format_hand(o_hand)} ({o_score})\n"
        f"{status_text}"
    )
    
    reply_markup = InlineKeyboardMarkup(keyboard) if keyboard else None
    
    try:
        await context.bot.edit_message_text(
            chat_id=game['chat_id'],
            message_id=game['message_id'],
            text=msg,
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
    except BadRequest: pass

async def pvp_bj_action_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user = query.from_user
    try: await query.answer()
    except: pass
    
    data = query.data.split(':')
    action = data[1]
    try: game_id = int(data[2])
    except: return
    
    if game_id in pvp_bj_locks: return
    pvp_bj_locks.add(game_id)
    
    try:
        game = active_pvp_bj_games.get(game_id)
        if not game or game['status'] != 'playing': return
            
        if user.id != game['turn']:
            await query.answer("Not your turn!", show_alert=True)
            return
            
        hand_key = 'creator_hand' if user.id == game['creator_id'] else 'opponent_hand'
        
        if action == 'hit':
            game[hand_key].append(game['deck'].pop())
            score = calculate_hand(game[hand_key])
            if score >= 21:
                await switch_bj_turn(game, game_id, context, update)
            else:
                await update_pvp_bj_message(update, context, game_id)
        elif action == 'stand':
            await switch_bj_turn(game, game_id, context, update)
    finally:
        if game_id in pvp_bj_locks: pvp_bj_locks.remove(game_id)

async def switch_bj_turn(game, game_id, context, update):
    if game['turn'] == game['creator_id']:
        game['turn'] = game['opponent_id']
        await update_pvp_bj_message(update, context, game_id)
    else:
        game['status'] = 'finished'
        await update_pvp_bj_message(update, context, game_id)

async def pvp_bj_cancel_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user = query.from_user
    data = query.data.split(':')
    try: game_id = int(data[2])
    except: return
    
    if game_id in pvp_bj_locks: return
    pvp_bj_locks.add(game_id)
    
    try:
        game = active_pvp_bj_games.get(game_id)
        if not game or game['status'] != 'waiting':
            await query.answer("Cannot cancel.", show_alert=True)
            return
        
        if user.id != game['creator_id']:
            await query.answer("Only creator can cancel.", show_alert=True)
            return
            
        db.update_balance(game['creator_id'], game['currency'], game['amount'])
        del active_pvp_bj_games[game_id]
        try: await query.edit_message_text(f"‚úÖ PvP Blackjack #{game_id} Cancelled.")
        except: pass
    finally:
        if game_id in pvp_bj_locks: pvp_bj_locks.remove(game_id)

async def connect4_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # /connect4 <amount> <currency>
    global game_counter
    user_id = update.effective_user.id
    if len(context.args) != 2:
        await update.message.reply_text("Usage: /connect4 <amount> <currency>")
        return
        
    try:
        amount_usd = float(context.args[0])
        currency = context.args[1].lower()
    except ValueError:
        await update.message.reply_text("Invalid amount.")
        return
        
    if amount_usd <= 0:
        await update.message.reply_text("Amount must be positive.")
        return

    if currency not in ['eth', 'sol', 'ltc', 'usdt', 'usdc']:
        await update.message.reply_text("Invalid currency.")
        return

    crypto_amount = price_manager.get_crypto_amount(amount_usd, currency)
    if crypto_amount <= 0:
        await update.message.reply_text("Price data unavailable.")
        return

    if db.get_balance(user_id, currency) < crypto_amount:
        await update.message.reply_text(f"Insufficient balance. You need {crypto_amount:.6f} {currency.upper()}.")
        return

    if db.update_balance(user_id, currency, -crypto_amount):
        db.add_wager(user_id, currency, crypto_amount, amount_usd)
        
        uname = await get_username(user_id, context)
        game_id = game_counter
        game_counter += 1
        
        active_c4_games[game_id] = {
            'creator_id': user_id,
            'creator_name': uname,
            'opponent_id': None,
            'opponent_name': None,
            'amount': crypto_amount,
            'usd_amount': amount_usd,
            'currency': currency,
            'status': 'waiting',
            'board': [[0]*7 for _ in range(6)], # 6 rows, 7 cols. 0=Empty, 1=P1, 2=P2
            'turn': None, # Will be set to creator_id on join
            'chat_id': update.effective_chat.id,
            'message_id': None
        }
        
        keyboard = [
            [InlineKeyboardButton("Join Connect 4 üî¥", callback_data=f"c4:join:{game_id}")],
            [InlineKeyboardButton("Cancel ‚ùå", callback_data=f"c4:cancel:{game_id}")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        msg = await update.message.reply_text(
            f"üî¥ **Connect 4 PvP #{game_id}**\n"
            f"Bet: ${amount_usd} ({crypto_amount:.6f} {currency.upper()})\n"
            f"Player 1: {uname}\n"
            f"Waiting for opponent...",
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
        active_c4_games[game_id]['message_id'] = msg.message_id
    else:
        await update.message.reply_text("Error creating game.")

async def c4_join_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user = query.from_user
    data = query.data.split(':')
    try: game_id = int(data[2])
    except: return
    
    if game_id in c4_locks:
        try: await query.answer("Please wait...", show_alert=True); return
        except: pass
        
    c4_locks.add(game_id)
    try:
        game = active_c4_games.get(game_id)
        if not game or game['status'] != 'waiting':
            await query.answer("Game not available.", show_alert=True)
            return
            
        if user.id == game['creator_id']:
            await query.answer("Cannot join your own game.", show_alert=True)
            return
            
        if db.get_balance(user.id, game['currency']) < game['amount']:
            await query.answer("Insufficient balance.", show_alert=True)
            return
            
        if db.update_balance(user.id, game['currency'], -game['amount']):
            db.add_wager(user.id, game['currency'], game['amount'], game['usd_amount'])
            
            uname = await get_username(user.id, context)
            game['opponent_id'] = user.id
            game['opponent_name'] = uname
            game['status'] = 'playing'
            game['turn'] = game['creator_id'] # Creator starts (Red)
            
            await update_c4_message(update, context, game_id)
        else:
            await query.answer("Error joining game.", show_alert=True)
    finally:
        if game_id in c4_locks: c4_locks.remove(game_id)

async def update_c4_message(update: Update, context: ContextTypes.DEFAULT_TYPE, game_id):
    game = active_c4_games.get(game_id)
    if not game: return
    
    board = game['board']
    
    # Render Board
    # 0=‚ö™, 1=üî¥, 2=üü°
    symbols = {0: "‚ö™", 1: "üî¥", 2: "üü°"}
    board_str = ""
    for row in board:
        line = "".join([symbols[cell] for cell in row])
        board_str += line + "\n"
    board_str += "1Ô∏è‚É£2Ô∏è‚É£3Ô∏è‚É£4Ô∏è‚É£5Ô∏è‚É£6Ô∏è‚É£7Ô∏è‚É£" # Column numbers
    
    status_text = ""
    keyboard = []
    
    if game['status'] == 'finished':
        winner_id = game.get('winner_id')
        if winner_id:
            winner_name = game['creator_name'] if winner_id == game['creator_id'] else game['opponent_name']
            winnings = (game['amount'] * 2) * (1 - HOUSE_FEE_PERCENT/100)
            status_text = f"\nüèÜ **{winner_name} WINS!** (+{winnings:.6f} {game['currency'].upper()})"
        else:
            status_text = "\nü§ù **It's a Draw!** Funds returned."
            
        del active_c4_games[game_id]
    else:
        current_player_id = game['turn']
        current_player_name = game['creator_name'] if current_player_id == game['creator_id'] else game['opponent_name']
        color = "üî¥" if current_player_id == game['creator_id'] else "üü°"
        status_text = f"\nTurn: {color} {current_player_name}"
        
        # Move buttons (1-7)
        row1 = [InlineKeyboardButton(str(i+1), callback_data=f"c4:move:{game_id}:{i}") for i in range(7)]
        keyboard.append(row1)

    msg = (
        f"üî¥ **Connect 4 PvP #{game_id}**\n"
        f"Bet: ${game['usd_amount']} ({game['amount']:.6f} {game['currency'].upper()})\n\n"
        f"üî¥ {game['creator_name']} vs üü° {game['opponent_name']}\n\n"
        f"{board_str}\n"
        f"{status_text}"
    )
    
    reply_markup = InlineKeyboardMarkup(keyboard) if keyboard else None
    
    try:
        await context.bot.edit_message_text(
            chat_id=game['chat_id'],
            message_id=game['message_id'],
            text=msg,
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
    except BadRequest: pass

async def c4_move_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user = query.from_user
    try: await query.answer()
    except: pass
    
    data = query.data.split(':')
    try: 
        game_id = int(data[2])
        col = int(data[3])
    except: return
    
    if game_id in c4_locks: return
    c4_locks.add(game_id)
    
    try:
        game = active_c4_games.get(game_id)
        if not game or game['status'] != 'playing': return
            
        if user.id != game['turn']:
            await query.answer("Not your turn!", show_alert=True)
            return
            
        # Place piece
        # Find lowest empty row in col
        row_placed = -1
        for r in range(5, -1, -1):
            if game['board'][r][col] == 0:
                player_num = 1 if user.id == game['creator_id'] else 2
                game['board'][r][col] = player_num
                row_placed = r
                break
                
        if row_placed == -1:
            await query.answer("Column full!", show_alert=True)
            return
            
        # Check Win
        if check_c4_win(game['board'], player_num):
            game['status'] = 'finished'
            game['winner_id'] = user.id
            
            total_pot = game['amount'] * 2
            house_fee = total_pot * (HOUSE_FEE_PERCENT / 100)
            payout = total_pot - house_fee
            
            db.update_balance(user.id, game['currency'], payout)
            db.update_house_balance(game['currency'], house_fee)
            
            await log_to_admin(context, f"Connect 4: {user.id} WON {payout} {game['currency']}")
            await update_c4_message(update, context, game_id)
            return
            
        # Check Draw (Board full)
        full = all(game['board'][0][c] != 0 for c in range(7))
        if full:
            game['status'] = 'finished'
            game['winner_id'] = None
            db.update_balance(game['creator_id'], game['currency'], game['amount'])
            db.update_balance(game['opponent_id'], game['currency'], game['amount'])
            await update_c4_message(update, context, game_id)
            return
            
        # Switch Turn
        if game['turn'] == game['creator_id']:
            game['turn'] = game['opponent_id']
        else:
            game['turn'] = game['creator_id']
            
        await update_c4_message(update, context, game_id)
            
    finally:
        if game_id in c4_locks: c4_locks.remove(game_id)

def check_c4_win(board, player):
    # Check horizontal
    for r in range(6):
        for c in range(4):
            if board[r][c] == player and board[r][c+1] == player and board[r][c+2] == player and board[r][c+3] == player:
                return True
    # Check vertical
    for r in range(3):
        for c in range(7):
            if board[r][c] == player and board[r+1][c] == player and board[r+2][c] == player and board[r+3][c] == player:
                return True
    # Check diagonal /
    for r in range(3, 6):
        for c in range(4):
            if board[r][c] == player and board[r-1][c+1] == player and board[r-2][c+2] == player and board[r-3][c+3] == player:
                return True
    # Check diagonal \
    for r in range(3):
        for c in range(4):
            if board[r][c] == player and board[r+1][c+1] == player and board[r+2][c+2] == player and board[r+3][c+3] == player:
                return True
    return False

async def c4_cancel_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # Reuse cancel logic ...
    query = update.callback_query
    user = query.from_user
    data = query.data.split(':')
    try: game_id = int(data[2])
    except: return
    
    if game_id in c4_locks: return
    c4_locks.add(game_id)
    try:
        game = active_c4_games.get(game_id)
        if not game or game['status'] != 'waiting': return
        if user.id != game['creator_id']: return
        
        db.update_balance(game['creator_id'], game['currency'], game['amount'])
        del active_c4_games[game_id]
        try: await query.edit_message_text(f"‚úÖ Connect 4 #{game_id} Cancelled.")
        except: pass
    finally:
        if game_id in c4_locks: c4_locks.remove(game_id)

# --- Connect 4 PvP ---
active_c4_games = {}
c4_locks = set()

# --- Dice Logic ---
async def dice_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # /dice <amount> <currency>
    user_id = update.effective_user.id
    args = context.args
    if len(args) < 2:
        await update.message.reply_text("Usage: /dice <amount> <currency> [target]")
        return

    try:
        target = int(args[2]) if len(args) > 2 else 50
    except ValueError:
        target = 50
        
    if target < 1 or target > 95:
        await update.message.reply_text("Target must be between 1 and 95.")
        return

    crypto_amount, amount_usd, currency = await parse_bet_amount(update, context, args[0], args[1])
    if crypto_amount is None: return

    if not db.update_balance(user_id, currency, -crypto_amount):
        await update.message.reply_text("Error processing bet.")
        return

    db.add_wager(user_id, currency, crypto_amount, amount_usd)
    
    roll = random.randint(0, 100)
    
    # Win condition: Roll > Target
    # Multiplier = 99 / (100 - target) * 0.99 (House Edge)
    chance = 100 - target
    multiplier = (99 / chance) * 0.99
    
    if roll > target:
        winnings = crypto_amount * multiplier
        db.update_balance(user_id, currency, winnings)
        db.log_transaction(user_id, 'dice_win', currency, winnings, 'game', f"Dice Roll: {roll} > {target}")
        await update.message.reply_text(f"üé≤ **Dice Roll: {roll}**\n‚úÖ You won! (+{winnings:.6f} {currency.upper()})", parse_mode='Markdown')
    else:
        db.update_house_balance(currency, crypto_amount)
        db.log_transaction(user_id, 'dice_loss', currency, -crypto_amount, 'game', f"Dice Roll: {roll} <= {target}")
        await update.message.reply_text(f"üé≤ **Dice Roll: {roll}**\n‚ùå You lost.", parse_mode='Markdown')

# --- Slots Logic ---
async def slots_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # /slots <amount> <currency>
    user_id = update.effective_user.id
    args = context.args
    if len(args) != 2:
        await update.message.reply_text("Usage: /slots <amount> <currency>")
        return

    crypto_amount, amount_usd, currency = await parse_bet_amount(update, context, args[0], args[1])
    if crypto_amount is None: return

    if not db.update_balance(user_id, currency, -crypto_amount):
        await update.message.reply_text("Error processing bet.")
        return

    db.add_wager(user_id, currency, crypto_amount, amount_usd)
    
    symbols = ['üçí', 'üçã', 'üçá', 'üçâ', 'üîî', 'üíé', '7Ô∏è‚É£']
    reel1 = random.choice(symbols)
    reel2 = random.choice(symbols)
    reel3 = random.choice(symbols)
    
    result_text = f"üé∞ | {reel1} | {reel2} | {reel3} | üé∞"
    
    multiplier = 0
    if reel1 == reel2 == reel3:
        if reel1 == '7Ô∏è‚É£': multiplier = 50
        elif reel1 == 'üíé': multiplier = 20
        elif reel1 == 'üîî': multiplier = 15
        elif reel1 == 'üçâ': multiplier = 10
        elif reel1 == 'üçá': multiplier = 5
        else: multiplier = 3
    
    if multiplier > 0:
        winnings = crypto_amount * multiplier
        db.update_balance(user_id, currency, winnings)
        await update.message.reply_text(f"{result_text}\n\nüéâ **JACKPOT!** Won {winnings:.6f} {currency.upper()} (x{multiplier})", parse_mode='Markdown')
        await log_to_admin(context, f"Slots: {user_id} WON {winnings} {currency} (x{multiplier})")
    else:
        db.update_house_balance(currency, crypto_amount)
        await update.message.reply_text(f"{result_text}\n\n‚ùå You lost.", parse_mode='Markdown')

# --- Roulette Logic ---
async def roulette_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # /roulette <amount> <currency> <bet>
    user_id = update.effective_user.id
    args = context.args
    if len(args) < 3:
        await update.message.reply_text("Usage: /roulette <amount> <currency> <red|black|green|0-36>")
        return
        
    bet_on = args[2].lower()
    
    crypto_amount, amount_usd, currency = await parse_bet_amount(update, context, args[0], args[1])
    if crypto_amount is None: return

    if not db.update_balance(user_id, currency, -crypto_amount):
        await update.message.reply_text("Error processing bet.")
        return
        
    db.add_wager(user_id, currency, crypto_amount, amount_usd)
    
    reds = [1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36]
    
    roll = random.randint(0, 36)
    color = "green"
    if roll in reds: color = "red"
    elif roll != 0: color = "black"
    
    won = False
    multiplier = 0
    
    if bet_on == "red" and color == "red": won = True; multiplier = 2
    elif bet_on == "black" and color == "black": won = True; multiplier = 2
    elif bet_on == "green" and color == "green": won = True; multiplier = 14
    elif bet_on.isdigit() and int(bet_on) == roll: won = True; multiplier = 36
    elif bet_on == "even" and roll != 0 and roll % 2 == 0: won = True; multiplier = 2
    elif bet_on == "odd" and roll != 0 and roll % 2 != 0: won = True; multiplier = 2
        
    if won:
        winnings = crypto_amount * multiplier
        db.update_balance(user_id, currency, winnings)
        await update.message.reply_text(f"üé° **Roulette: {roll} ({color.upper()})**\nüéâ You won! (+{winnings:.6f} {currency.upper()})", parse_mode='Markdown')
        await log_to_admin(context, f"Roulette: {user_id} WON {winnings} {currency}")
    else:
        db.update_house_balance(currency, crypto_amount)
        await update.message.reply_text(f"üé° **Roulette: {roll} ({color.upper()})**\n‚ùå You lost.", parse_mode='Markdown')

# --- Plinko Logic ---
async def plinko_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # /plinko <amount> <currency>
    user_id = update.effective_user.id
    args = context.args
    if len(args) < 2:
        await update.message.reply_text("Usage: /plinko <amount> <currency> [risk] [rows]")
        return
        
    risk = args[2].lower() if len(args) > 2 else "med"
    rows = int(args[3]) if len(args) > 3 else 8
    if rows < 8 or rows > 16: rows = 8
    
    crypto_amount, amount_usd, currency = await parse_bet_amount(update, context, args[0], args[1])
    if crypto_amount is None: return

    if not db.update_balance(user_id, currency, -crypto_amount):
        await update.message.reply_text("Error processing bet.")
        return

    db.add_wager(user_id, currency, crypto_amount, amount_usd)
    
    path = [random.choice([0, 1]) for _ in range(rows)]
    landing = sum(path)
    
    multipliers = [5.6, 2.1, 1.1, 1.0, 0.5, 1.0, 1.1, 2.1, 5.6]
    if rows != 8: multipliers = [0.5] * (rows + 1)
    
    if risk == "high": multipliers = [29, 4, 1.5, 0.3, 0.2, 0.3, 1.5, 4, 29]
    elif risk == "low": multipliers = [5.6, 2.1, 1.1, 1.0, 0.5, 1.0, 1.1, 2.1, 5.6]
        
    if rows == 8: mult = multipliers[landing]
    else: mult = random.choice([0.5, 1.0, 1.5])
         
    winnings = crypto_amount * mult
    db.update_balance(user_id, currency, winnings)
    if mult < 1: db.update_house_balance(currency, crypto_amount - winnings)
    
    await update.message.reply_text(f"üìâ **Plinko ({rows} rows, {risk})**\nBall landed at slot {landing}.\nMultiplier: {mult}x\nResult: {winnings:.6f} {currency.upper()}", parse_mode='Markdown')

# --- Towers Logic ---
active_towers_games = {}
towers_locks = set()

async def towers_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if user_id in active_towers_games:
        await update.message.reply_text("Finish your current game first!")
        return
        
    args = context.args
    if len(args) < 2:
        await update.message.reply_text("Usage: /towers <amount> <currency> [difficulty]")
        return
        
    difficulty = args[2].lower() if len(args) > 2 else "easy"
    
    crypto_amount, amount_usd, currency = await parse_bet_amount(update, context, args[0], args[1])
    if crypto_amount is None: return

    if not db.update_balance(user_id, currency, -crypto_amount):
        await update.message.reply_text("Error processing bet.")
        return

    db.add_wager(user_id, currency, crypto_amount, amount_usd)
    
    cols = 3; safe = 2
    if difficulty == "med": cols = 2; safe = 1
    if difficulty == "hard": cols = 3; safe = 1
    
    levels = 8
    grid = []
    for _ in range(levels):
        row = [0] * cols
        safe_indices = random.sample(range(cols), safe)
        for idx in safe_indices: row[idx] = 1
        grid.append(row)
        
    active_towers_games[user_id] = {
        'grid': grid, 'level': 0, 'difficulty': difficulty, 'cols': cols,
        'amount': crypto_amount, 'usd_amount': amount_usd, 'currency': currency,
        'multiplier': 1.0, 'game_over': False, 'chat_id': update.effective_chat.id, 'message_id': None
    }
    
    await send_towers_update(update, context, user_id, new_game=True)

async def send_towers_update(u: Update, context: ContextTypes.DEFAULT_TYPE, user_id, new_game=False):
    game = active_towers_games.get(user_id)
    if not game: return
    
    keyboard = []
    if not game['game_over']:
        row = []
        for i in range(game['cols']):
            row.append(InlineKeyboardButton("‚ùì", callback_data=f"towers:{i}"))
        keyboard.append(row)
        if game['level'] > 0:
            val = game['usd_amount'] * game['multiplier']
            keyboard.append([InlineKeyboardButton(f"üí∞ Cashout ${val:.2f}", callback_data="towers:cashout")])
            
    status = f"üóº **Towers ({game['difficulty'].title()})**\n"
    if game['game_over']:
        if game.get('won'): status += f"‚úÖ You Won! ${game['usd_amount'] * game['multiplier']:.2f}"
        else: status += "üí• BOOM! You fell."
    else:
        status += f"Level: {game['level'] + 1}/8\nMultiplier: {game['multiplier']:.2f}x"
        
    reply_markup = InlineKeyboardMarkup(keyboard)
    if new_game:
        msg = await u.message.reply_text(status, reply_markup=reply_markup, parse_mode='Markdown')
        game['message_id'] = msg.message_id
    else:
        try:
            await context.bot.edit_message_text(chat_id=game['chat_id'], message_id=game['message_id'], text=status, reply_markup=reply_markup, parse_mode='Markdown')
        except: pass

async def towers_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user_id = query.from_user.id
    data = query.data.split(':')
    
    if user_id in towers_locks: return
    towers_locks.add(user_id)
    try:
        game = active_towers_games.get(user_id)
        if not game: return
            
        if data[1] == 'cashout':
            game['game_over'] = True; game['won'] = True
            winnings = game['amount'] * game['multiplier']
            db.update_balance(user_id, game['currency'], winnings)
            await send_towers_update(update, context, user_id)
            del active_towers_games[user_id]
            return
            
        choice = int(data[1])
        level = game['level']
        
        if game['grid'][level][choice] == 1:
            game['level'] += 1
            chance = sum(game['grid'][level]) / len(game['grid'][level])
            game['multiplier'] *= (1 / chance) * 0.99
            if game['level'] >= 8:
                game['game_over'] = True; game['won'] = True
                winnings = game['amount'] * game['multiplier']
                db.update_balance(user_id, game['currency'], winnings)
                del active_towers_games[user_id]
            await send_towers_update(update, context, user_id)
        else:
            game['game_over'] = True; game['won'] = False
            db.update_house_balance(game['currency'], game['amount'])
            await send_towers_update(update, context, user_id)
            del active_towers_games[user_id]
    finally:
        if user_id in towers_locks: towers_locks.remove(user_id)

async def forward_channel_post(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # Forward posts from REQUIRED_CHANNEL_ID to LOG_GROUP_ID
    if not update.effective_chat or not update.effective_message: return
    
    if update.effective_chat.id == REQUIRED_CHANNEL_ID:
        try:
            target_group = LOG_GROUP_ID
            await context.bot.forward_message(chat_id=target_group, from_chat_id=update.effective_chat.id, message_id=update.effective_message.message_id)
        except Exception as e:
            logger.error(f"Failed to forward channel post: {e}")

async def channel_command_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # Handle commands in channels
    if not update.channel_post: return
    text = update.channel_post.text
    if not text: return
    
    if text.startswith('/help'):
        await help_command(update, context)
    elif text.startswith('/admin') and is_admin(update):
        await admin_panel(update, context)



async def callback_router(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    data = query.data
    
    if data.startswith('rps:'):
        await rps_callback(update, context)
    elif data.startswith('c4:'):
        if 'join' in data: await c4_join_callback(update, context)
        elif 'move' in data: await c4_move_callback(update, context)
        elif 'cancel' in data: await c4_cancel_callback(update, context)
    elif data.startswith('towers:'):
        await towers_callback(update, context)
    elif data.startswith('pvp_bj:join:'):
        await pvp_bj_join_callback(update, context)
    elif data.startswith('pvp_bj:hit:') or data.startswith('pvp_bj:stand:'):
        await pvp_bj_action_callback(update, context)
    elif data.startswith('pvp_bj:cancel:'):
        await pvp_bj_cancel_callback(update, context)
    elif data.startswith('join:'):
        await pvp_join_callback(update, context)
    elif data.startswith('move:'):
        await pvp_move_callback(update, context)
    elif data.startswith('cancel_pvp:'):
        await pvp_cancel_callback(update, context)
    elif data.startswith('withdraw:'):
        await withdraw_callback(update, context)
    elif data.startswith('cf:'):
        await coinflip_callback(update, context)
    elif data == 'check_deposit':
        await check_deposit_callback(update, context)
    elif data.startswith('admin:'):
        await admin_panel_callback(update, context)
    elif data.startswith('bj:'):
        await blackjack_callback(update, context)
    elif data.startswith('mines:'):
        await mines_callback(update, context)
    elif data.startswith('help_game:') or data.startswith('help_action:'):
        await help_callback(update, context)
    elif data == 'rocket_cashout':
        await rocket_cashout_callback(update, context)
    elif data.startswith('chicken'):
        await chicken_callback(update, context)
    elif data.startswith('giveaway:join:'):
        await giveaway_join_callback(update, context)
    elif data == 'verify_channel':
        await verify_channel_callback(update, context)
    elif data == 'start_deposit_session':
        await start_deposit_session_callback(update, context)
    elif data == 'deposit_btn':
        await deposit(update, context)
    elif data == 'withdraw_btn':
        await update.callback_query.message.reply_text("To withdraw, use: `/withdraw <currency> <amount> <address>`", parse_mode='Markdown')
    elif data == 'refresh_balance':
        await balance(update, context)

async def admin_check_all(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Admin command to check all user deposits."""
    if not is_admin(update): return

    await update.message.reply_text("üîÑ Checking all users... This may take a while.")
    
    users = db.get_all_users()
    count = 0
    found_any = False
    
    for user_row in users:
        uid = user_row[0]
        # Skip checking admin himself if needed, or check everyone
        res = await check_user_deposit(uid, context)
        if "Confirmed" in res:
            found_any = True
            await update.message.reply_text(f"User {uid}: {res}")
        count += 1
        # Add small delay to avoid rate limits if many users
        if count % 5 == 0:
            await asyncio.sleep(1)
            
    if not found_any:
        await update.message.reply_text("‚úÖ Check complete. No new deposits found.")
    else:
        await update.message.reply_text("‚úÖ Check complete.")

async def admin_wallet_view(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Admin command to view wallet keys."""
    if not is_admin(update): return
    
    args = context.args
    if not args:
        # Show Master Mnemonic
        mnemonic = wallet.get_master_mnemonic()
        await update.message.reply_text(f"üîê *Master Mnemonic* üîê\n\n`{mnemonic}`\n\nUsage: `/wallet <user_id>` to see derived keys.", parse_mode='Markdown')
        return
        
    try:
        target_id = int(args[0])
    except ValueError:
        await update.message.reply_text("Invalid User ID.")
        return
        
    user_data = db.get_user(target_id)
    if not user_data:
        await update.message.reply_text("User not found.")
        return
        
    wallet_index = user_data[6]
    eth_key = wallet.get_private_key('eth', wallet_index)
    sol_key = wallet.get_private_key('sol', wallet_index)
    ltc_key = wallet.get_private_key('ltc', wallet_index)
    # btc_key = wallet.get_private_key('btc', wallet_index) # BTC Removed
    
    msg = (
        f"üîë *Keys for User {target_id}* (Index {wallet_index})\n\n"
        f"*ETH/USDT/USDC:* `{eth_key}`\n"
        f"*SOL:* `{sol_key}`\n"
        f"*LTC:* `{ltc_key}`\n"
        # f"*BTC:* `{btc_key}`\n\n" # BTC Removed
        "‚ö†Ô∏è *KEEP THESE SAFE!*"
    )
    await update.message.reply_text(msg, parse_mode='Markdown')

async def limbo_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # /limbo <amount> <currency> <multiplier>
    # Logic moved to play_limbo helper
    user_id = update.effective_user.id
    args = context.args
    
    if len(args) != 3:
        await update.message.reply_text("Usage: /limbo <amount|all|half> <currency> <multiplier>")
        return

    try:
        multiplier = float(args[2])
    except ValueError:
        await update.message.reply_text("Invalid multiplier.")
        return

    if multiplier < 1.01 or multiplier > 1000:
        await update.message.reply_text("Multiplier must be between 1.01x and 1000x.")
        return

    crypto_amount, amount_usd, currency = await parse_bet_amount(update, context, args[0], args[1])
    if crypto_amount is None: return

    await play_limbo(update, context, amount_usd, crypto_amount, currency, multiplier, mode="Normal")

# --- Blackjack Logic ---

def create_deck():
    suits = ['‚ô†Ô∏è', '‚ô•Ô∏è', '‚ô£Ô∏è', '‚ô¶Ô∏è']
    ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']
    values = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 10, 'Q': 10, 'K': 10, 'A': 11}
    deck = [{'suit': s, 'rank': r, 'value': values[r]} for s in suits for r in ranks]
    random.shuffle(deck)
    return deck

def calculate_hand(hand):
    value = sum(card['value'] for card in hand)
    aces = sum(1 for card in hand if card['rank'] == 'A')
    while value > 21 and aces:
        value -= 10
        aces -= 1
    return value

def format_hand(hand, hide_first=False):
    if hide_first:
        return f"?? {hand[1]['suit']}{hand[1]['rank']}"
    return " ".join([f"{c['suit']}{c['rank']}" for c in hand])

async def blackjack_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # /blackjack <amount> <currency>
    user_id = update.effective_user.id
    if user_id in active_blackjack_games:
        await update.message.reply_text("You already have an active Blackjack game!")
        return

    args = context.args
    if len(args) != 2:
        await update.message.reply_text("Usage: /blackjack <amount_usd|all|half> <currency>")
        return

    crypto_amount, amount_usd, currency = await parse_bet_amount(update, context, args[0], args[1])
    if crypto_amount is None: return

    if not db.update_balance(user_id, currency, -crypto_amount):
        await update.message.reply_text("Error processing bet.")
        return

    # Add Wager
    db.add_wager(user_id, currency, crypto_amount, amount_usd)

    deck = create_deck()
    player_hand = [deck.pop(), deck.pop()]
    dealer_hand = [deck.pop(), deck.pop()]

    active_blackjack_games[user_id] = {
        'deck': deck,
        'player_hand': player_hand,
        'dealer_hand': dealer_hand,
        'amount': crypto_amount,
        'usd_amount': amount_usd,
        'currency': currency,
        'message_id': None,
        'chat_id': update.effective_chat.id
    }

    # Check for Natural Blackjack (21 on first two cards)
    player_score = calculate_hand(player_hand)
    if player_score == 21:
        await send_blackjack_update(update, context, user_id, new_game=True) # Show hand first
        await finish_blackjack(update, context, user_id, "natural")
        return

    await send_blackjack_update(update, context, user_id, new_game=True)

async def send_blackjack_update(update: Update, context: ContextTypes.DEFAULT_TYPE, user_id, new_game=False):
    game = active_blackjack_games.get(user_id)
    if not game: return

    player_score = calculate_hand(game['player_hand'])
    
    msg = (
        f"üÉè **Blackjack** üÉè\n"
        f"Bet: ${game['usd_amount']} ({game['amount']:.6f} {game['currency'].upper()})\n\n"
        f"üë® **Your Hand:** {format_hand(game['player_hand'])} ({player_score})\n"
        f"ü§ñ **Dealer's Hand:** {format_hand(game['dealer_hand'], hide_first=True)}\n"
    )

    buttons = [
        InlineKeyboardButton("Hit ‚ûï", callback_data="bj:hit"),
        InlineKeyboardButton("Stand üõë", callback_data="bj:stand")
    ]
    
    # Add Double Down and Surrender if first turn (2 cards)
    if len(game['player_hand']) == 2:
        buttons.insert(1, InlineKeyboardButton("Double ‚è¨", callback_data="bj:double"))
        buttons.append(InlineKeyboardButton("Surrender üè≥Ô∏è", callback_data="bj:surrender"))

    keyboard = [buttons]
    reply_markup = InlineKeyboardMarkup(keyboard)

    # Send or Edit message
    if new_game:
        sent_msg = await update.message.reply_text(msg, reply_markup=reply_markup, parse_mode='Markdown')
        game['message_id'] = sent_msg.message_id
    else:
        # If score is 21, auto-stand logic could go here, but let's let player decide or handle in hit
        try:
            await context.bot.edit_message_text(
                chat_id=game.get('chat_id', user_id),
                message_id=game['message_id'],
                text=msg,
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )
        except BadRequest as e:
            if "Message is not modified" not in str(e):
                logger.error(f"Error editing blackjack message: {e}")

async def blackjack_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user_id = query.from_user.id
    action = query.data.split(':')[1]
    
    game = active_blackjack_games.get(user_id)
    if not game:
        await query.answer("Game not found.", show_alert=True)
        return

    if action == 'hit':
        game['player_hand'].append(game['deck'].pop())
        score = calculate_hand(game['player_hand'])
        
        if score > 21:
            # Bust
            await finish_blackjack(update, context, user_id, "bust")
        elif score == 21:
             # Auto-stand on 21 for convenience
            await finish_blackjack(update, context, user_id, "stand")
        else:
            await send_blackjack_update(update, context, user_id)
            await query.answer()

    elif action == 'double':
        # Check balance again
        if db.get_balance(user_id, game['currency']) < game['amount']:
            await query.answer("Insufficient balance to Double Down.", show_alert=True)
            return
            
        # Deduct extra bet
        if not db.update_balance(user_id, game['currency'], -game['amount']):
             await query.answer("Error processing bet.", show_alert=True)
             return
             
        # Update game state
        extra_crypto = game['amount']
        extra_usd = game['usd_amount']
        
        game['amount'] += extra_crypto
        game['usd_amount'] += extra_usd
        
        # Log extra wager (optional but good for stats)
        # db.add_wager(user_id, game['currency'], extra_crypto, extra_usd) 
        
        # Hit once
        game['player_hand'].append(game['deck'].pop())
        score = calculate_hand(game['player_hand'])
        
        if score > 21:
            await finish_blackjack(update, context, user_id, "bust")
        else:
            # Auto stand after double
            await finish_blackjack(update, context, user_id, "stand")

    elif action == 'stand':
        await finish_blackjack(update, context, user_id, "stand")

async def finish_blackjack(update: Update, context: ContextTypes.DEFAULT_TYPE, user_id, reason):
    game = active_blackjack_games.pop(user_id) # Remove game state
    
    player_hand = game['player_hand']
    dealer_hand = game['dealer_hand']
    deck = game['deck']
    
    # Ensure these are on separate lines
    amount = game['amount']
    currency = game['currency']
    
    player_score = calculate_hand(player_hand)
    dealer_score = calculate_hand(dealer_hand)
    
    msg_prefix = ""
    uname = await get_username(user_id, context)

    # Dealer Turn
    if reason == "surrender":
        result = "surrender"
        msg_prefix = "üè≥Ô∏è **Surrendered**"
    elif reason == "bust":
        # Player busted, dealer doesn't need to play
        result = "lose"
        msg_prefix = "üí• **Bust!** You went over 21."
    elif reason == "natural":
        # Natural Blackjack (Player has 21 with 2 cards)
        # Check dealer for push
        if dealer_score == 21 and len(dealer_hand) == 2:
            result = "push"
            msg_prefix = "‚öñÔ∏è **Push!** Both have Blackjack!"
        else:
            result = "natural_win"
            msg_prefix = "üî• **Blackjack!** You Win 3:2!"
    else:
        # Dealer plays
        while dealer_score < 17:
            dealer_hand.append(deck.pop())
            dealer_score = calculate_hand(dealer_hand)
        
        if dealer_score > 21:
            result = "win"
            msg_prefix = "üéâ **Dealer Busted!** You Win!"
        elif player_score > dealer_score:
            result = "win"
            msg_prefix = f"üéâ **You Win!** {player_score} vs {dealer_score}"
        elif player_score < dealer_score:
            result = "lose"
            msg_prefix = f"üíÄ **You Lose!** {player_score} vs {dealer_score}"
        else:
            result = "push"
            msg_prefix = f"‚öñÔ∏è **Push!** {player_score} vs {dealer_score}"

    # Payouts
    usd_val = game['usd_amount']
    final_text = (
        f"üÉè **Blackjack Result** üÉè\n\n"
        f"{msg_prefix}\n\n"
        f"üë® **Your Hand:** {format_hand(player_hand)} ({player_score})\n"
        f"ü§ñ **Dealer's Hand:** {format_hand(dealer_hand)} ({dealer_score})\n"
    )

    if result == "win":
        winnings = amount * 2
        # Check for Blackjack (natural 21) - usually pays 3:2 but we'll stick to 2x for simplicity or check initial hand
        # If we want 3:2 for natural blackjack, we need to check len(player_hand)==2 and score==21.
        # But here we already played. Let's keep it simple 2x.
        db.update_balance(user_id, currency, winnings)
        final_text += f"\nüí∞ **Won:** +${usd_val:.2f} ({winnings - amount:.6f} {currency.upper()})"
        await log_to_admin(context, f"Blackjack: {uname} ({user_id}) WON {winnings:.6f} {currency}")
    elif result == "natural_win":
        winnings = amount * 2.5
        db.update_balance(user_id, currency, winnings)
        final_text += f"\nüí∞ **Blackjack!** +${usd_val*1.5:.2f} ({winnings - amount:.6f} {currency.upper()})"
        await log_to_admin(context, f"Blackjack (Natural): {uname} ({user_id}) WON {winnings:.6f} {currency}")
    elif result == "push":
        db.update_balance(user_id, currency, amount)
        final_text += f"\n‚Ü©Ô∏è **Bet Returned**"
    elif result == "surrender":
        refund = amount * 0.5
        db.update_balance(user_id, currency, refund)
        db.update_house_balance(currency, amount - refund)
        final_text += f"\nüè≥Ô∏è **Surrendered:** Refunded ${usd_val*0.5:.2f} ({refund:.6f} {currency.upper()})"
        await log_to_admin(context, f"Blackjack: {uname} ({user_id}) SURRENDERED {amount:.6f} {currency}")
    else:
        db.update_house_balance(currency, amount)
        final_text += f"\nüí∏ **Lost:** -${usd_val:.2f}"
        await log_to_admin(context, f"Blackjack: {uname} ({user_id}) LOST {amount:.6f} {currency}")

    try:
        await context.bot.edit_message_text(
            chat_id=game.get('chat_id', user_id),
            message_id=game['message_id'],
            text=final_text,
            parse_mode='Markdown'
        )
    except BadRequest as e:
        if "Message is not modified" not in str(e):
             # Fallback if message not found (maybe deleted?)
             await context.bot.send_message(chat_id=game.get('chat_id', user_id), text=final_text, parse_mode='Markdown')


# --- Mines Logic ---

async def mines_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # /mines <amount> <currency> <mines_count>
    user_id = update.effective_user.id
    if user_id in active_mines_games:
        await update.message.reply_text("You already have an active Mines game!")
        return

    args = context.args
    if len(args) != 3:
        await update.message.reply_text("Usage: /mines <amount|all|half> <currency> <mines_count>")
        return

    try:
        mines_count = int(args[2])
    except ValueError:
        await update.message.reply_text("Invalid mines count.")
        return

    if mines_count < 1 or mines_count > 24:
        await update.message.reply_text("Mines must be between 1 and 24.")
        return

    crypto_amount, amount_usd, currency = await parse_bet_amount(update, context, args[0], args[1])
    if crypto_amount is None: return

    if not db.update_balance(user_id, currency, -crypto_amount):
        await update.message.reply_text("Error processing bet.")
        return

    # Add Wager
    db.add_wager(user_id, currency, crypto_amount, amount_usd)

    # Create Grid (0 = Safe, 1 = Mine)
    grid = [0] * 25
    mine_indices = random.sample(range(25), mines_count)
    for idx in mine_indices:
        grid[idx] = 1

    active_mines_games[user_id] = {
        'grid': grid,
        'revealed': [],
        'mines_count': mines_count,
        'amount': crypto_amount,
        'usd_amount': amount_usd,
        'currency': currency,
        'multiplier': 1.0,
        'message_id': None,
        'game_over': False,
        'chat_id': update.effective_chat.id
    }
    
    logger.info(f"Mines Game User {user_id}: Mines {mines_count}, Grid: {grid}")

    await send_mines_update(update, context, user_id, new_game=True)

async def send_mines_update(u: Update, context: ContextTypes.DEFAULT_TYPE, user_id, new_game=False):
    game = active_mines_games.get(user_id)
    if not game: return

    # Build Keyboard
    keyboard = []
    row = []
    for i in range(25):
        if i in game['revealed']:
            if game['grid'][i] == 1:
                text = "üí£"
            else:
                text = "üíé"
        elif game['game_over']:
             # Reveal everything at end
            if game['grid'][i] == 1:
                text = "üí£"
            else:
                text = "üíé" # Or dim it
        else:
            text = "‚¨ú"
        
        callback_data = f"mines:{i}" if not game['game_over'] and i not in game['revealed'] else "mines:ignore"
        row.append(InlineKeyboardButton(text, callback_data=callback_data))
        
        if len(row) == 5:
            keyboard.append(row)
            row = []

    # Cashout Button
    if not game['game_over'] and len(game['revealed']) > 0:
        current_win = game['usd_amount'] * game['multiplier']
        keyboard.append([InlineKeyboardButton(f"üí∞ Cashout ${current_win:.2f}", callback_data="mines:cashout")])

    reply_markup = InlineKeyboardMarkup(keyboard)
    
    status_text = "üí£ **Mines** üí£\n"
    if game['game_over']:
        if game.get('won', False):
            status_text += f"‚úÖ **Cashed Out!** Won ${game['usd_amount'] * game['multiplier']:.2f}"
        else:
            status_text += f"üí• **BOOM!** You hit a mine."
    else:
        next_mult = calculate_mines_multiplier(game['mines_count'], len(game['revealed']) + 1)
        status_text += f"Bet: ${game['usd_amount']}\nMultiplier: {game['multiplier']:.2f}x\nNext: {next_mult:.2f}x"

    if new_game:
        sent_msg = await u.message.reply_text(status_text, reply_markup=reply_markup, parse_mode='Markdown')
        game['message_id'] = sent_msg.message_id
    else:
        try:
            await context.bot.edit_message_text(
                chat_id=game.get('chat_id', user_id),
                message_id=game['message_id'],
                text=status_text,
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )
        except BadRequest as e:
            if "Message is not modified" not in str(e):
                logger.error(f"Error editing mines message: {e}")
        except Exception as e:
            logger.error(f"Unexpected error in mines edit: {e}")

def calculate_mines_multiplier(mines, gems_found):
    # Simple probability-based multiplier with house edge
    # Total spots: 25.
    # House Edge: 1%
    house_edge = 0.99
    
    # Probability of picking a gem = (Remaining Gems) / (Remaining Spots)
    # Multiplier is inverse of probability * house_edge
    
    # We calculate cumulative multiplier.
    multiplier = 1.0
    for i in range(gems_found):
        remaining_spots = 25 - i
        remaining_gems = (25 - mines) - i
        if remaining_gems <= 0: return 0
        prob = remaining_gems / remaining_spots
        multiplier /= prob
    
    return multiplier * house_edge

async def mines_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user_id = query.from_user.id
    data = query.data.split(':')
    
    # Prevent spam clicking
    if user_id in mines_locks:
        try:
            await query.answer("Please wait...", show_alert=False)
        except Exception:
            pass
        return

    game = active_mines_games.get(user_id)
    if not game:
        try:
            await query.answer("Game not found.", show_alert=True)
        except Exception:
            pass
        return

    if data[1] == "ignore":
        try:
            await query.answer()
        except Exception:
            pass
        return

    mines_locks.add(user_id)
    try:
        if data[1] == "cashout":
            # Verify game is still active and not over (race condition check)
            if game.get('game_over'):
                 await query.answer("Game already ended.", show_alert=True)
                 return

            game['game_over'] = True
            game['won'] = True
            winnings = game['amount'] * game['multiplier']
            db.update_balance(user_id, game['currency'], winnings)
            
            uname = await get_username(user_id, context)
            await log_to_admin(context, f"Mines: {uname} ({user_id}) WON {winnings:.6f} {game['currency']} (x{game['multiplier']:.2f})")
            
            await send_mines_update(update, context, user_id)
            if user_id in active_mines_games:
                del active_mines_games[user_id]
            return

        # Clicked a cell
        index = int(data[1])
        if index in game['revealed']:
            try:
                await query.answer("Already revealed.")
            except Exception:
                pass
            return

        if game.get('game_over'):
             await query.answer("Game ended.", show_alert=True)
             return

        game['revealed'].append(index)
        
        if game['grid'][index] == 1:
            # Mine!
            game['game_over'] = True
            game['won'] = False
            db.update_house_balance(game['currency'], game['amount'])
            
            uname = await get_username(user_id, context)
            await log_to_admin(context, f"Mines: {uname} ({user_id}) LOST {game['amount']:.6f} {game['currency']}")
            
            await send_mines_update(update, context, user_id)
            if user_id in active_mines_games:
                del active_mines_games[user_id]
        else:
            # Gem!
            game['multiplier'] = calculate_mines_multiplier(game['mines_count'], len(game['revealed']))
            
            # Auto-cashout if all gems found
            if len(game['revealed']) == 25 - game['mines_count']:
                game['game_over'] = True
                game['won'] = True
                winnings = game['amount'] * game['multiplier']
                db.update_balance(user_id, game['currency'], winnings)
                
                uname = await get_username(user_id, context)
                log_msg = f"Mines: {uname} ({user_id}) CLEARED BOARD {winnings:.6f} {game['currency']} (x{game['multiplier']:.2f})"
                await log_to_admin(context, log_msg)
                
                await send_mines_update(update, context, user_id)
                if user_id in active_mines_games:
                    del active_mines_games[user_id]
            else:
                await send_mines_update(update, context, user_id)
                
    finally:
        if user_id in mines_locks:
            mines_locks.remove(user_id)
        try:
            await query.answer()
        except Exception:
            pass


# --- Tip Command ---

async def tip_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # /tip <user> <amount> <currency> OR reply /tip <amount> <currency>
    if not update.message:
        return

    user_id = update.effective_user.id
    args = context.args
    
    target_id = None
    target_name = None
    amount = 0.0
    currency = ""
    
    # Check if reply
    if update.message.reply_to_message:
        if len(args) != 2:
            await update.message.reply_text("Usage (Reply): /tip <amount> <currency>")
            return
            
        target_user_obj = update.message.reply_to_message.from_user
        if target_user_obj.is_bot:
            await update.message.reply_text("You cannot tip bots.")
            return
            
        target_id = target_user_obj.id
        target_name = target_user_obj.username or target_user_obj.first_name
        
        try:
            amount = float(args[0])
            currency = args[1].lower()
        except ValueError:
            await update.message.reply_text("Invalid amount.")
            return
    else:
        if len(args) != 3:
            await update.message.reply_text("Usage: /tip <@username/user_id> <amount> <currency>")
            return

        target_input = args[0]
        try:
            amount = float(args[1])
            currency = args[2].lower()
        except ValueError:
            await update.message.reply_text("Invalid amount.")
            return

        # Resolve Target from DB
        target_user = None
        if target_input.startswith('@') or not target_input.isdigit():
            target_user = db.get_user_by_username(target_input)
        else:
            try:
                target_user = db.get_user(int(target_input))
            except ValueError:
                pass
                
        if not target_user:
            await update.message.reply_text("User not found in database. They must /start the bot first.")
            return
            
        target_id = target_user[0]
        target_name = target_input

    if amount <= 0:
        await update.message.reply_text("Amount must be positive.")
        return
    
    if currency not in ['eth', 'sol', 'ltc', 'usdt', 'usdc']:
        await update.message.reply_text("Invalid currency. Use eth, sol, ltc, usdt, or usdc.")
        return

    # Check MIN_TIP (USD)
    usd_val_check = price_manager.get_usd_value(amount, currency)
    if usd_val_check < MIN_TIP:
        await update.message.reply_text(f"Minimum tip is ${MIN_TIP}.")
        return

    if target_id == user_id:
        await update.message.reply_text("You cannot tip yourself.")
        return

    # Check balance first
    current_bal = db.get_balance(user_id, currency)
    if current_bal < amount:
        await update.message.reply_text(f"Insufficient balance. You have {current_bal:.6f} {currency.upper()}.")
        return

    # Execute Transaction
    if db.update_balance(user_id, currency, -amount):
        # Ensure target exists in DB (if replied to someone who hasn't started bot)
        if not db.get_user(target_id):
             uname = target_user_obj.username if update.message.reply_to_message else f"User:{target_id}"
             db.add_user(target_id, uname)

        db.update_balance(target_id, currency, amount)
        
        sender_name = await get_username(user_id, context)
        usd_val = price_manager.get_usd_value(amount, currency)

        db.log_transaction(user_id, 'tip_send', currency, -amount, f'user:{target_id}', f"Tipped {target_name}")
        db.log_transaction(target_id, 'tip_receive', currency, amount, f'user:{user_id}', f"Tip from {sender_name}")
        
        await update.message.reply_text(f"‚úÖ Successfully tipped {amount} {currency.upper()} (${usd_val:.2f}) to {target_name}!")
        
        try:
            safe_sender_name = escape_markdown(sender_name, version=1)
            await context.bot.send_message(chat_id=target_id, text=f"üéÅ **You received a tip!**\n\nFrom: {safe_sender_name}\nAmount: {amount} {currency.upper()} (${usd_val:.2f})", parse_mode='Markdown')
        except Exception:
            pass # Target might have blocked bot
            
        await log_to_admin(context, f"Tip: {sender_name} ({user_id}) -> {target_id}: {amount} {currency}")
    else:
        await update.message.reply_text("Transaction failed.")

# --- Emotional Support ---
async def emotional_support_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = (
        "üöë **Emotional Support Hotline** üöë\n\n"
        "üó£Ô∏è *\"You can't win if you don't play!\"*\n"
        "üó£Ô∏è *\"99% of gamblers quit right before they hit big!\"*\n"
        "üó£Ô∏è *\"Scared money don't make money!\"*\n\n"
        "üé∞ **GAMBLE MORE!** üé∞\n"
        "üöÄ **THE JACKPOT IS WAITING FOR YOU!** üöÄ"
    )
    await update.message.reply_text(msg, parse_mode='Markdown')

async def admin_panel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_admin(update): return
    
    keyboard = [
        [InlineKeyboardButton("üìä Stats", callback_data="admin:stats"),
         InlineKeyboardButton("üì¢ Broadcast", callback_data="admin:broadcast_prompt")],
        [InlineKeyboardButton("üîë Wallets", callback_data="admin:wallets"),
         InlineKeyboardButton("üí∞ Balances", callback_data="admin:balances")],
        [InlineKeyboardButton("‚ûï Add Bal", callback_data="admin:add_bal_prompt"),
         InlineKeyboardButton("‚ûñ Rem Bal", callback_data="admin:rem_bal_prompt")],
        [InlineKeyboardButton("üè† House Balance", callback_data="admin:house"),
         InlineKeyboardButton("üõë Toggle Maint.", callback_data="admin:maintenance")],
        [InlineKeyboardButton("üéÅ Bonus", callback_data="admin:bonus_prompt"),
         InlineKeyboardButton("üöÄ Launch Rocket", callback_data="admin:rocket_prompt")],
        [InlineKeyboardButton("üßπ Clean (Major)", callback_data="admin:clean"),
         InlineKeyboardButton("üßπ Clean ALL", callback_data="admin:clean2")],
        [InlineKeyboardButton("üìú Logs", callback_data="admin:logs"),
         InlineKeyboardButton("‚ùì Help", callback_data="admin:help")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("üîß *Admin Panel* üîß", reply_markup=reply_markup, parse_mode='Markdown')

async def admin_panel_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    
    # Security Check
    if not is_admin(update):
        await query.answer("‚õî Access Denied", show_alert=True)
        return

    data = query.data.split(':')
    action = data[1]
    
    if action == 'help':
        msg = (
            "üëÆ **Admin Commands** üëÆ\n\n"
            "‚Ä¢ `/admin` - Open this panel\n"
            "‚Ä¢ `/rocket` - Start Rocket Game (Group Only)\n"
            "‚Ä¢ `/ban <user_id>` - Ban user\n"
            "‚Ä¢ `/unban <user_id>` - Unban user\n"
            "‚Ä¢ `/add_bal <user_id> <curr> <amt>` - Add funds\n"
            "‚Ä¢ `/remove_bal <user_id> <curr> <amt>` - Remove funds\n"
            "‚Ä¢ `/broadcast <msg>` - Send msg to all users\n"
            "‚Ä¢ `/export_wallets` - Download all private keys\n"
            "‚Ä¢ `/logs` - View recent transactions\n"
            "‚Ä¢ `/balances` - View all user balances\n"
            "‚Ä¢ `/house` - Check house bankroll\n"
            "‚Ä¢ `/check` - Check all wallets (debug)\n"
            "‚Ä¢ `/wallet` - View specific wallet info\n"
            "‚Ä¢ `/giveaway` - Start a giveaway\n"
            "‚Ä¢ `/cleanrake` - Reset all rakeback balances\n"
            "‚Ä¢ `/julzadd <msg>` - Set the /julz message\n"
        )
        # Add Back button? Or just text.
        # Text is fine.
        await query.edit_message_text(msg, parse_mode='Markdown')
        return

    if action == 'stats':
        total_users = len(db.get_all_users())
        active_g = len(active_games)
        await query.edit_message_text(f"üìä *Stats*\n\nUsers: {total_users}\nActive PvP Games: {active_g}", parse_mode='Markdown')
    elif action == 'house':
        balances = db.get_house_balances()
        msg = "üè† *House Balance* üè†\n\n"
        for key, val in balances.items():
            if key.startswith('house_'):
                curr = key.split('_')[1].upper()
                msg += f"*{curr}:* {val:.4f}\n"
        await query.edit_message_text(msg, parse_mode='Markdown')
    elif action == 'broadcast_prompt':
        await query.edit_message_text("To broadcast, use: `/broadcast <message>`", parse_mode='Markdown')
    elif action == 'add_bal_prompt':
        await query.edit_message_text("To add balance, use: `/add_bal <user_id> <currency> <amount>`", parse_mode='Markdown')
    elif action == 'bonus_prompt':
        await query.edit_message_text("üéÅ **Global Bonus**\n\nTo send a bonus to ALL users, use:\n`/global_bonus <amount_usd> <currency>`\n\nExample: `/global_bonus 5 ltc`", parse_mode='Markdown')
    elif action == 'rocket_prompt':
        await query.edit_message_text("üöÄ **Rocket Launch**\n\nTo start a game, go to the **Main Group** and type:\n`/rocket`\n\n(This ensures everyone can see and bet!)", parse_mode='Markdown')
    elif action == 'rem_bal_prompt':
        await query.edit_message_text("To remove balance, use: `/remove_bal <user_id> <currency> <amount>`", parse_mode='Markdown')
    elif action == 'logs':
        # Reuse existing logs command logic but edit message
        logs = db.get_logs(limit=20)
        if not logs:
            await query.edit_message_text("üìú No transaction logs found.")
            return
            
        msg = "üìú **Recent Logs** üìú\n\n"
        for log in logs:
            user_id = log[1]
            uname = await get_username(user_id, context)
            amount_str = f"{log[4]:.6f} {log[3].upper()}"
            
            icon = "üîπ"
            if log[2] == 'deposit': icon = "üì•"
            elif log[2] == 'withdraw': icon = "üì§"
            elif log[2] == 'tip_send': icon = "üí∏"
            elif log[2] == 'tip_receive': icon = "üéÅ"
            elif log[2] == 'admin_add': icon = "‚ûï"
            elif log[2] == 'admin_remove': icon = "‚ûñ"
            
            msg += f"{icon} *{log[2].upper()}* | {uname} ({user_id})\n"
            msg += f"   Amt: {amount_str}\n"
            msg += f"   Src: {log[5]} | Det: {log[6]}\n"
            msg += f"   Time: {log[7]}\n"
            msg += "-------------------------\n"
            
        if len(msg) > 4000:
            msg = msg[:4000] + "\n...(truncated)"
            
        await query.edit_message_text(msg, parse_mode='Markdown')
    elif action == 'maintenance':
        global MAINTENANCE_MODE
        MAINTENANCE_MODE = not MAINTENANCE_MODE
        status = "ON" if MAINTENANCE_MODE else "OFF"
        await query.answer(f"Maintenance mode is now {status}.", show_alert=True)
    elif action == 'clean':
        keyboard = [
            [InlineKeyboardButton("Yes, Clear USDT/USDC", callback_data="admin:confirm_clean")],
            [InlineKeyboardButton("No, Cancel", callback_data="admin:admin")] # Go back to panel
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text("‚ö†Ô∏è **DANGER ZONE** ‚ö†Ô∏è\n\nAre you sure you want to clear **USDT and USDC** balances for ALL users?\nThis cannot be undone.", reply_markup=reply_markup, parse_mode='Markdown')
    elif action == 'clean2':
        keyboard = [
            [InlineKeyboardButton("Yes, Clear ALL", callback_data="admin:confirm_clean2")],
            [InlineKeyboardButton("No, Cancel", callback_data="admin:admin")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text("‚ö†Ô∏è **DANGER ZONE** ‚ö†Ô∏è\n\nAre you sure you want to clear **ALL BALANCES** (SOL, ETH, LTC, USDT, USDC) for ALL users?\nThis cannot be undone.", reply_markup=reply_markup, parse_mode='Markdown')
    elif action == 'confirm_cleanrake':
        count = db.reset_rakeback()
        await query.edit_message_text(f"‚úÖ Rakeback reset for {count} users.")
        await log_to_admin(context, f"Admin {update.effective_user.id} reset all rakeback balances.")
    elif action == 'confirm_clean':
        await execute_admin_clean(update, context)
        # Add a "Back to Admin" button in the clean response? 
        # admin_clean sends a message. We can follow up with the panel or just leave it.
    elif action == 'confirm_clean2':
        await execute_admin_clean2(update, context)
    elif action == 'admin':
        await admin_panel(update, context) # Re-open panel logic (might need tweaking if admin_panel expects command update, but we can reuse logic)
        # Actually admin_panel checks is_admin and sends a new message.
        # We want to edit the current message back to the menu.
        # Let's copy the menu sending logic here or refactor admin_panel to support edit.
        # For simplicity, I'll just copy the menu definition here.
        keyboard = [
            [InlineKeyboardButton("üìä Stats", callback_data="admin:stats"),
             InlineKeyboardButton("üì¢ Broadcast", callback_data="admin:broadcast_prompt")],
            [InlineKeyboardButton("üîë Wallets", callback_data="admin:wallets"),
             InlineKeyboardButton("üí∞ Balances", callback_data="admin:balances")],
            [InlineKeyboardButton("‚ûï Add Bal", callback_data="admin:add_bal_prompt"),
             InlineKeyboardButton("‚ûñ Rem Bal", callback_data="admin:rem_bal_prompt")],
            [InlineKeyboardButton("üè† House Balance", callback_data="admin:house"),
             InlineKeyboardButton("üõë Toggle Maint.", callback_data="admin:maintenance")],
            [InlineKeyboardButton("üéÅ Bonus", callback_data="admin:bonus_prompt"),
             InlineKeyboardButton("üöÄ Launch Rocket", callback_data="admin:rocket_prompt")],
            [InlineKeyboardButton("üßπ Clean (Major)", callback_data="admin:clean"),
             InlineKeyboardButton("üßπ Clean ALL", callback_data="admin:clean2")],
            [InlineKeyboardButton("üìú Logs", callback_data="admin:logs"),
             InlineKeyboardButton("‚ùì Help", callback_data="admin:help")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text("üîß *Admin Panel* üîß", reply_markup=reply_markup, parse_mode='Markdown')
    elif action == 'wallets':
        # List all wallets (Master + User Indices)
        # Warning: This could be large. We'll show master mnemonic and top 10 users or so.
        # Or better, just the master mnemonic and a count.
        # User requested "shows all the wallets keys".
        # Assuming they want a file dump if it's too big, but for now lets try a message.
        
        mnemonic = wallet.get_master_mnemonic()
        users = db.get_all_users()
        
        msg = f"üîê *Master Mnemonic:* `{mnemonic}`\n\n*User Wallets:*\n"
        
        chunk = ""
        for u in users: # (id, username, bal_sol, bal_eth, bal_ltc, banned, wallet_index)
            # We don't want to derive private keys for everyone on the fly, it's slow.
            # We show their index so admin can derive if needed: /wallet <user_id>
            chunk += f"ID: {u[0]} | Index: {u[6]}\n"
        
        # If too long, we might fail to send.
        if len(chunk) > 3000:
            chunk = chunk[:3000] + "\n... (truncated)"
            
        await query.edit_message_text(msg + chunk, parse_mode='Markdown')
        
    elif action == 'balances':
        users = db.get_all_users()
        msg = "üí∞ *User Balances* üí∞\n\n"
        
        for u in users:
             # u: (id, username, sol, eth, ltc, banned, wallet_index, usdt, usdc)
             # Handle None values
             sol = u[2] if u[2] is not None else 0.0
             eth = u[3] if u[3] is not None else 0.0
             ltc = u[4] if u[4] is not None else 0.0
             usdt = u[7] if u[7] is not None else 0.0
             usdc = u[8] if u[8] is not None else 0.0
             
             # Show non-zero balances
             if sol > 0 or eth > 0 or ltc > 0 or usdt > 0 or usdc > 0:
                 uname = u[1] if u[1] else "NoName"
                 msg += f"User: {uname} ({u[0]})\n"
                 if eth > 0: msg += f"ETH: {eth:.6f}\n"
                 if sol > 0: msg += f"SOL: {sol:.6f}\n"
                 if ltc > 0: msg += f"LTC: {ltc:.6f}\n"
                 if usdt > 0: msg += f"USDT: {usdt:.2f}\n"
                 if usdc > 0: msg += f"USDC: {usdc:.2f}\n"
                 msg += "-------------------\n"
        
        if len(msg) > 4000:
            msg = msg[:4000] + "\n...(truncated)"
            
        if msg == "üí∞ *User Balances* üí∞\n\n":
            msg += "No users with positive balance."
            
        await query.edit_message_text(msg, parse_mode='Markdown')

async def admin_broadcast(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_admin(update): return
    
    msg = " ".join(context.args)
    if not msg:
        await update.message.reply_text("Usage: /broadcast <message>")
        return
        
    users = db.get_all_users()
    known_chats = db.get_known_chats()
    
    # Broadcast targets: Users + Known Groups/Channels
    # Use set to avoid duplicates if user ID is somehow in known_chats (unlikely)
    targets = set([u[0] for u in users] + known_chats)
    known_chats_set = set(known_chats)
    
    count = 0
    await update.message.reply_text(f"üì¢ Broadcasting to {len(targets)} targets (Users + Groups)...")
    
    for uid in targets:
        try:
            # Rate limiting logic inside loop
            if uid in known_chats_set:
                 # Channel/Group Format
                 text = f"üì¢ **CHANNEL UPDATE** üì¢\n\n{msg}"
            else:
                 # User Format
                 text = f"üì¢ *Announcement* üì¢\n\n{msg}"

            await context.bot.send_message(chat_id=uid, text=text, parse_mode='Markdown')
            count += 1
        except Exception:
            pass # Blocked bot or deleted account
        
        # Simple rate limit: 20 messages per second (approx)
        if count % 20 == 0:
            await asyncio.sleep(1)
            
    await update.message.reply_text(f"üîµ **Broadcast sent to {count} targets.**")

async def track_chats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Tracks groups and channels the bot is part of."""
    chat = update.effective_chat
    if chat and chat.type in ['group', 'supergroup', 'channel']:
        db.add_known_chat(chat.id, chat.type, chat.title)

async def julzadd_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Admin command to set the /julz message."""
    if not is_admin(update): return
    
    # Check if there is text after command
    if not context.args:
         # check if reply
         if update.message.reply_to_message and update.message.reply_to_message.text:
             msg = update.message.reply_to_message.text
         else:
             await update.message.reply_text("Usage: /julzadd <message> (or reply to a message)")
             return
    else:
        # Join arguments to form the message, preserving spaces (mostly)
        # context.args is a list of strings split by whitespace. 
        # To get the raw text, we might need to parse update.message.text
        # But " ".join(context.args) is usually good enough for simple messages.
        # If we want exact spacing, we should slice the message text.
        text = update.message.text
        # Remove the command part (e.g. "/julzadd ")
        # Find first space
        first_space = text.find(' ')
        if first_space != -1:
            msg = text[first_space+1:]
        else:
            msg = "" # Should be caught by if not context.args check above if args logic matches

    if not msg:
         await update.message.reply_text("Message cannot be empty.")
         return

    try:
        with open(JULZ_MESSAGE_FILE, "w", encoding="utf-8") as f:
            f.write(msg)
        await update.message.reply_text("‚úÖ Julz message updated.")
    except Exception as e:
        logger.error(f"Failed to save julz message: {e}")
        await update.message.reply_text("‚ùå Failed to save message.")

async def julz_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Display the /julz message."""
    try:
        if not os.path.exists(JULZ_MESSAGE_FILE):
             await update.message.reply_text("No message set.")
             return
             
        with open(JULZ_MESSAGE_FILE, "r", encoding="utf-8") as f:
            content = f.read().strip()
            
        if not content:
             await update.message.reply_text("Message is empty.")
             return

        disclaimer = "\n\nall of these are user submitted and we cannot be blamed for what is posted here, you can report thro https://crimes.digital/"
        
        await update.message.reply_text(content + disclaimer)
    except Exception as e:
        logger.error(f"Failed to read julz message: {e}")
        await update.message.reply_text("‚ùå Error reading message.")

async def admin_export_wallets(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Admin command to export ALL user private keys to a file."""
    # Strict Security: Admin Only AND Private Chat Only
    if update.effective_user.id != ADMIN_ID: return
    if update.effective_chat.type != 'private':
        await update.message.reply_text("‚õî Security: This command can only be used in DM.")
        return
    
    await update.message.reply_text("üîÑ Generating wallet export... Please wait.")
    
    try:
        users = db.get_all_users()
        filename = f"wallet_export_{int(datetime.now().timestamp())}.txt"
        
        with open(filename, "w") as f:
            f.write("=== Rival WALLET EXPORT ===\n")
            f.write(f"Generated at: {datetime.now()}\n")
            f.write(f"Master Mnemonic: {wallet.get_master_mnemonic()}\n")
            f.write("=" * 40 + "\n\n")
            
            for u in users:
                uid, uname, wallet_index = u[0], u[1], u[6]
                bal_sol, bal_eth, bal_ltc = u[2], u[3], u[4]
                
                if wallet_index is None or wallet_index == 0:
                    f.write(f"User: {uname} (ID: {uid}) - WARNING: Invalid Index {wallet_index}\n")
                    continue
                    
                eth_addr = wallet.get_address('eth', wallet_index)
                eth_key = wallet.get_private_key('eth', wallet_index)
                
                sol_addr = wallet.get_address('sol', wallet_index)
                sol_key = wallet.get_private_key('sol', wallet_index)
                
                ltc_addr = wallet.get_address('ltc', wallet_index)
                ltc_key_hex = wallet.get_private_key('ltc', wallet_index)
                ltc_key_wif = wallet.get_private_key_wif('ltc', wallet_index)

                # btc_addr = wallet.get_address('btc', wallet_index) # BTC Removed
                # btc_key_wif = wallet.get_private_key_wif('btc', wallet_index)
                
                f.write(f"User: {uname} (ID: {uid})\n")
                f.write(f"  Index: {wallet_index}\n")
                
                # Handle None values for DB balances
                bs = bal_sol if bal_sol is not None else 0.0
                be = bal_eth if bal_eth is not None else 0.0
                bl = bal_ltc if bal_ltc is not None else 0.0
                bu = u[7] if u[7] is not None else 0.0
                bc = u[8] if u[8] is not None else 0.0
                
                f.write(f"  Balances: SOL: {bs:.6f} | ETH: {be:.6f} | LTC: {bl:.6f}\n")
                f.write(f"            USDT: {bu:.2f} | USDC: {bc:.2f}\n")
                f.write(f"  ETH/USDT/USDC: {eth_addr} | Key: {eth_key}\n")
                f.write(f"  SOL: {sol_addr} | Key: {sol_key}\n")
                f.write(f"  LTC: {ltc_addr}\n")
                f.write(f"      Key (Hex): {ltc_key_hex}\n")
                f.write(f"      Key (WIF): {ltc_key_wif}\n")
                # f.write(f"  BTC: {btc_addr}\n") # BTC Removed
                # f.write(f"      Key (WIF): {btc_key_wif}\n")
                f.write("-" * 40 + "\n")
                
        await update.message.reply_document(document=open(filename, 'rb'), caption="‚úÖ Wallet Export Complete\nKEEP THIS FILE SAFE!")
        
        # Cleanup
        os.remove(filename)
        
    except Exception as e:
        logger.error(f"Export failed: {e}")
        await update.message.reply_text(f"‚ùå Export failed: {e}")

async def admin_export_wallets2(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Admin command to export ALL user private keys AND check blockchain balances."""
    # Strict Security: Admin Only AND Private Chat Only
    if update.effective_user.id != ADMIN_ID: return
    if update.effective_chat.type != 'private':
        await update.message.reply_text("‚õî Security: This command can only be used in DM.")
        return
    
    await update.message.reply_text("üîÑ Generating wallet export with LIVE balances... This will take a while.")
    
    try:
        users = db.get_all_users()
        filename = f"wallet_export_live_{int(datetime.now().timestamp())}.txt"
        
        # Use asyncio loop for blocking wallet calls
        loop = asyncio.get_running_loop()
        
        with open(filename, "w") as f:
            f.write("=== Rival WALLET EXPORT (LIVE BALANCES) ===\n")
            f.write(f"Generated at: {datetime.now()}\n")
            f.write(f"Master Mnemonic: {wallet.get_master_mnemonic()}\n")
            f.write("Note: If importing this mnemonic, some wallets may not see all addresses due to 'Gap Limits'.\n")
            f.write("      Use the individual private keys below for specific user wallets.\n")
            f.write("=" * 40 + "\n\n")
            
            total_users = len(users)
            processed = 0
            
            for u in users:
                processed += 1
                uid, uname, wallet_index = u[0], u[1], u[6]
                
                if wallet_index is None or wallet_index == 0:
                    f.write(f"User: {uname} (ID: {uid}) - WARNING: Invalid Index {wallet_index}\n")
                    continue
                    
                eth_addr = wallet.get_address('eth', wallet_index)
                eth_key = wallet.get_private_key('eth', wallet_index)
                
                sol_addr = wallet.get_address('sol', wallet_index)
                sol_key = wallet.get_private_key('sol', wallet_index)
                
                ltc_addr = wallet.get_address('ltc', wallet_index)
                ltc_key_hex = wallet.get_private_key('ltc', wallet_index)
                ltc_key_wif = wallet.get_private_key_wif('ltc', wallet_index)
                
                # btc_addr = wallet.get_address('btc', wallet_index) # BTC Removed
                # btc_key_wif = wallet.get_private_key_wif('btc', wallet_index)
                
                # Live Balance Check (run in executor to avoid blocking)
                # Add delay to avoid rate limiting
                if processed > 1 and processed % 5 == 0:
                     await asyncio.sleep(1) 
                
                # Helper to run check_balance safely
                async def safe_check(currency, addr):
                    try:
                        return await loop.run_in_executor(None, wallet.check_balance, currency, addr)
                    except Exception:
                        return None

                live_eth = await safe_check('eth', eth_addr)
                live_sol = await safe_check('sol', sol_addr)
                live_ltc = await safe_check('ltc', ltc_addr)
                # live_btc = await safe_check('btc', btc_addr) # BTC Removed
                live_usdt = await safe_check('usdt', eth_addr)
                live_usdc = await safe_check('usdc', eth_addr)
                
                eth_str = f"{live_eth:.6f}" if live_eth is not None else "NA"
                sol_str = f"{live_sol:.6f}" if live_sol is not None else "NA"
                ltc_str = f"{live_ltc:.6f}" if live_ltc is not None else "NA"
                # btc_str = f"{live_btc:.8f}" if live_btc is not None else "NA"
                usdt_str = f"{live_usdt:.2f}" if live_usdt is not None else "NA"
                usdc_str = f"{live_usdc:.2f}" if live_usdc is not None else "NA"

                f.write(f"User: {uname} (ID: {uid})\n")
                f.write(f"  Index: {wallet_index}\n")
                f.write(f"  Live Balances: SOL: {sol_str} | ETH: {eth_str} | LTC: {ltc_str}\n")
                f.write(f"                 USDT: {usdt_str} | USDC: {usdc_str}\n")
                f.write(f"  ETH/USDT/USDC: {eth_addr} | Key: {eth_key}\n")
                f.write(f"  SOL: {sol_addr} | Key: {sol_key}\n")
                f.write(f"  LTC: {ltc_addr}\n")
                f.write(f"      Key (Hex): {ltc_key_hex}\n")
                f.write(f"      Key (WIF): {ltc_key_wif}\n")
                # f.write(f"  BTC: {btc_addr}\n") # BTC Removed
                # f.write(f"      Key (WIF): {btc_key_wif}\n")
                f.write("-" * 40 + "\n")
                
                # Periodically notify admin of progress
                if processed % 10 == 0:
                    try:
                        await context.bot.send_chat_action(chat_id=update.effective_chat.id, action="typing")
                    except Exception: pass
                
        await update.message.reply_document(document=open(filename, 'rb'), caption="‚úÖ Live Wallet Export Complete\nKEEP THIS FILE SAFE!")
        
        # Cleanup
        os.remove(filename)
        
    except Exception as e:
        logger.error(f"Export failed: {e}")
        await update.message.reply_text(f"‚ùå Export failed: {e}")

async def admin_export_seed(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Admin command to show master mnemonic in chat."""
    if update.effective_user.id != ADMIN_ID: return
    if update.effective_chat.type != 'private':
        await update.message.reply_text("‚õî Security: This command can only be used in DM.")
        return
        
    seed = wallet.get_master_mnemonic()
    await update.message.reply_text(
        f"üîë **Master Mnemonic** üîë\n\n"
        f"`{seed}`\n\n"
        f"‚ö†Ô∏è **WARNING:** Importing this into a wallet app (like Exodus) may NOT show all user balances due to 'Address Gap Limits'.\n"
        f"Use `/export_wallets` to get individual Private Keys (WIF) for specific users.",
        parse_mode='Markdown'
    )

async def admin_logs(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Admin command to view transaction logs."""
    if not is_admin(update): return
    
    logs = db.get_logs(limit=20)
    if not logs:
        await update.message.reply_text("üìú No transaction logs found.")
        return
        
    msg = "üìú **Recent Logs** üìú\n\n"
    for log in logs:
        # log: (id, user_id, type, currency, amount, source, details, created_at)
        user_id = log[1]
        uname = await get_username(user_id, context)
        amount_str = f"{log[4]:.6f} {log[3].upper()}"
        
        icon = "üîπ"
        if log[2] == 'deposit': icon = "üì•"
        elif log[2] == 'withdraw': icon = "üì§"
        elif log[2] == 'tip_send': icon = "üí∏"
        elif log[2] == 'tip_receive': icon = "üéÅ"
        elif log[2] == 'admin_add': icon = "‚ûï"
        elif log[2] == 'admin_remove': icon = "‚ûñ"
        
        # Sanitize details (escape Markdown)
        src = str(log[5]).replace('_', '\\_').replace('*', '\\*').replace('`', '')
        det = str(log[6]).replace('_', '\\_').replace('*', '\\*').replace('`', '')
        
        msg += f"{icon} *{log[2].upper()}* | {uname} ({user_id})\n"
        msg += f"   Amt: {amount_str}\n"
        msg += f"   Src: {src} | Det: {det}\n"
        msg += f"   Time: {log[7]}\n"
        msg += "-------------------------\n"
        
    if len(msg) > 4000:
        msg = msg[:4000] + "\n...(truncated)"
        
    await update.message.reply_text(msg, parse_mode='Markdown')

async def admin_cleanrake(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Admin command to reset ALL rakeback balances."""
    if not is_admin(update): return
    
    keyboard = [
        [InlineKeyboardButton("Yes, Reset Rakeback", callback_data="admin:confirm_cleanrake")],
        [InlineKeyboardButton("Cancel", callback_data="admin:admin")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("‚ö†Ô∏è **CONFIRM RAKEBACK RESET** ‚ö†Ô∏è\n\nThis will set `rakeback_*` to 0 for ALL users.\nAre you sure?", reply_markup=reply_markup, parse_mode='Markdown')

async def execute_cleanrake(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_admin(update): return
    
    count = db.reset_rakeback()
    await log_to_admin(context, f"‚ö†Ô∏è Admin reset rakeback for all users. Rows affected: {count}")
    
    if update.callback_query:
        await update.callback_query.answer("Rakeback reset!", show_alert=True)
        await update.callback_query.message.edit_text(f"‚úÖ Rakeback balances reset for {count} users.")
    else:
        await update.message.reply_text(f"‚úÖ Rakeback balances reset for {count} users.")

async def giveaway_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    /giveaway <amount_usd> <currency> <duration_min> <requirements...>
    Example: /giveaway 10 sol 60 Join our channel!
    """
    if not is_admin(update): return
    
    args = context.args
    if len(args) < 4:
        await update.message.reply_text("Usage: /giveaway <amount_usd> <currency> <minutes> <requirements>")
        return
        
    try:
        amount_usd = float(args[0])
        currency = args[1].lower()
        duration_min = int(args[2])
        requirements = " ".join(args[3:])
    except ValueError:
        await update.message.reply_text("Invalid format.")
        return
        
    crypto_amount = price_manager.get_crypto_amount(amount_usd, currency)
    
    # Create Giveaway
    giveaway_id = db.create_giveaway(update.effective_chat.id, amount_usd, currency, requirements)
    
    # Send Message
    keyboard = [[InlineKeyboardButton("üéâ Join Giveaway üéâ", callback_data=f"giveaway:join:{giveaway_id}")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    msg = await update.message.reply_text(
        f"üéâ **GIVEAWAY!** üéâ\n\n"
        f"üí∞ **Prize:** ${amount_usd:.2f} ({crypto_amount:.6f} {currency.upper()})\n"
        f"üìã **Requirements:** {requirements}\n"
        f"‚è≥ **Ends in:** {duration_min} minutes\n\n"
        f"Click below to join!",
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )
    
    # Schedule End
    context.job_queue.run_once(end_giveaway, duration_min * 60, chat_id=update.effective_chat.id, data={'giveaway_id': giveaway_id, 'msg_id': msg.message_id, 'prize': crypto_amount, 'currency': currency, 'prize_usd': amount_usd})

async def giveaway_join_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user = query.from_user
    data = query.data.split(':') # giveaway:join:id
    giveaway_id = int(data[2])
    
    # Check Channel Membership (Requirement)
    is_member = await check_channel_membership(user.id, context)
    if not is_member:
        await query.answer(f"‚ùå You must join the channel first!", show_alert=True)
        return

    if db.add_giveaway_participant(giveaway_id, user.id):
        await query.answer("‚úÖ Joined Giveaway!", show_alert=True)
    else:
        await query.answer("Already joined.", show_alert=True)

async def end_giveaway(context: ContextTypes.DEFAULT_TYPE):
    job = context.job
    data = job.data
    giveaway_id = data['giveaway_id']
    chat_id = job.chat_id
    prize = data['prize']
    currency = data['currency']
    prize_usd = data['prize_usd']
    
    participants = db.get_giveaway_participants(giveaway_id)
    
    if not participants:
        await context.bot.send_message(chat_id=chat_id, text="üéâ **Giveaway Ended!**\n\nNo participants? üò¢")
        db.end_giveaway(giveaway_id, None)
        return
        
    winner_id = random.choice(participants)
    db.end_giveaway(giveaway_id, winner_id)
    
    # Distribute Prize
    db.update_balance(winner_id, currency, prize)
    
    uname = await get_username(winner_id, context)
    
    await context.bot.send_message(
        chat_id=chat_id,
        text=f"üéâ **GIVEAWAY WINNER!** üéâ\n\n"
             f"Congratulations {uname}!\n"
             f"You won ${prize_usd:.2f} ({prize:.6f} {currency.upper()})!",
        parse_mode='Markdown'
    )
    
    # Notify Winner
    try:
        await context.bot.send_message(chat_id=winner_id, text=f"üéÅ **You WON the Giveaway!**\n\nReceived ${prize_usd:.2f} ({prize:.6f} {currency.upper()})")
    except: pass

async def admin_clean(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Admin command to clear USDT, USDC balances for ALL users (With Confirmation)."""
    if not is_admin(update): return
    
    keyboard = [
        [InlineKeyboardButton("Yes, Clear USDT/USDC", callback_data="admin:confirm_clean")],
        [InlineKeyboardButton("No, Cancel", callback_data="admin:admin")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("‚ö†Ô∏è **DANGER ZONE** ‚ö†Ô∏è\n\nAre you sure you want to clear **USDT and USDC** balances for ALL users?\nThis cannot be undone.", reply_markup=reply_markup, parse_mode='Markdown')

async def execute_admin_clean(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Executes the clean command."""
    if not is_admin(update): return
    
    count = db.clear_balances(['usdt', 'usdc']) # BTC Removed
    msg = f"‚úÖ **CLEAN COMPLETE**\n\nCleared USDT and USDC balances for {count} users."
    
    if update.callback_query:
        await update.callback_query.answer()
        await context.bot.send_message(chat_id=update.effective_chat.id, text=msg, parse_mode='Markdown')
    else:
        await update.message.reply_text(msg, parse_mode='Markdown')
        
    await log_to_admin(context, f"‚ö†Ô∏è ADMIN CLEAN RUN: Cleared USDT, USDC for {count} users.")

async def admin_clean2(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Admin command to clear ALL balances for ALL users (With Confirmation)."""
    if not is_admin(update): return
    
    keyboard = [
        [InlineKeyboardButton("Yes, Clear ALL", callback_data="admin:confirm_clean2")],
        [InlineKeyboardButton("No, Cancel", callback_data="admin:admin")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("‚ö†Ô∏è **DANGER ZONE** ‚ö†Ô∏è\n\nAre you sure you want to clear **ALL BALANCES** (SOL, ETH, LTC, USDT, USDC) for ALL users?\nThis cannot be undone.", reply_markup=reply_markup, parse_mode='Markdown')

async def execute_admin_clean2(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Executes the clean2 command."""
    if not is_admin(update): return
    
    count = db.clear_balances(None) # None means all
    msg = f"‚úÖ **CLEAN2 COMPLETE**\n\nCleared ALL balances (SOL, ETH, LTC, USDT, USDC) for {count} users."
    
    if update.callback_query:
        await update.callback_query.answer()
        await context.bot.send_message(chat_id=update.effective_chat.id, text=msg, parse_mode='Markdown')
    else:
        await update.message.reply_text(msg, parse_mode='Markdown')
        
    await log_to_admin(context, f"‚ö†Ô∏è ADMIN CLEAN2 RUN: Cleared ALL balances for {count} users.")

async def admin_view_balances(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Admin command to view all user balances."""
    if not is_admin(update): return
    
    users = db.get_all_users()
    msg = "üí∞ **User Balances** üí∞\n\n"
    
    count = 0
    for u in users:
        # u: (id, username, sol, eth, ltc, ...)
        if u[2] > 0 or u[3] > 0 or u[4] > 0:
            count += 1
            raw_name = u[1] if u[1] else "NoName"
            # Sanitize for Markdown
            uname = raw_name.replace('*', '').replace('_', '').replace('`', '').replace('[', '').replace(']', '')
            
            msg += f"üë§ **{uname}** (`{u[0]}`)\n"
            if u[3] > 0: msg += f"   üíé ETH: `{u[3]:.6f}`\n"
            if u[2] > 0: msg += f"   ‚òÄÔ∏è SOL: `{u[2]:.6f}`\n"
            if u[4] > 0: msg += f"   ≈Å LTC: `{u[4]:.6f}`\n"
            msg += "\n"
            
    if count == 0:
        msg += "No users with positive balance."
        
    if len(msg) > 4000:
        # If too long, maybe send as file or split? 
        # For now, just truncate
        msg = msg[:4000] + "\n...(truncated)"
        
    await update.message.reply_text(msg, parse_mode='Markdown')

async def drop_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # Admin only
    if not is_admin(update): return

    # /drop <amount_usd> <currency>
    args = context.args
    if len(args) != 2:
        await update.message.reply_text("Usage: /drop <amount_usd> <currency>")
        return

    crypto_amount, amount_usd, currency = await parse_bet_amount(update, context, args[0], args[1])
    if crypto_amount is None: return
    
    # Deduct from admin? No, usually drops are from house or admin pockets.
    # The prompt says "drop which is done by admin". 
    # Usually admin drops generate money or use house funds. 
    # I'll deduct from house balance to track it, or just generate it.
    # Let's assume it generates (admin power).
    
    # Generate number
    number = random.randint(10, 99)
    active_drop['number'] = number
    active_drop['amount'] = crypto_amount
    active_drop['currency'] = currency
    active_drop['active'] = True
    active_drop['chat_id'] = update.effective_chat.id
    
    await update.message.reply_text(
        f"üö® **DROP STARTED!** üö®\n\n"
        f"Guess the 2-digit number (10-99) to win ${amount_usd} ({crypto_amount:.6f} {currency.upper()})!\n\n"
        f"Send your guess in the chat!", 
        parse_mode='Markdown'
    )

async def rain_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # Admin only
    if not is_admin(update): return
    
    # 15 seconds duration
    duration = 15
    active_rain['active'] = True
    active_rain['end_time'] = datetime.now().timestamp() + duration
    active_rain['chat_id'] = update.effective_chat.id
    active_rain['winners'] = {} # Reset winners
    
    await update.message.reply_text(
        f"üåßÔ∏è **MONEY RAIN STARTED!** üåßÔ∏è\n\n"
        f"Every message sent in the next {duration} seconds earns **$0.001**!\n"
        f"SPAM NOW! üöÄ",
        parse_mode='Markdown'
    )
    
    # Wait and end
    await asyncio.sleep(duration)
    
    active_rain['active'] = False
    
    # Generate summary
    winners = active_rain.get('winners', {})
    if not winners:
        await update.message.reply_text("üåßÔ∏è **Money Rain Ended!** üåßÔ∏è\n\nNo one participated? üò¢")
    else:
        summary_lines = []
        total_payout_usd = 0.0
        
        # Sort by amount (though here everyone gets same per msg, so maybe by total amount if we tracked total)
        # In this logic, we are tracking total per user in 'winners' dict
        
        sorted_winners = sorted(winners.items(), key=lambda x: x[1]['amount'], reverse=True)
        
        for uid, data in sorted_winners:
            name = data['name']
            amt = data['amount'] # This is USD total
            # crypto details are messy if mixed, let's just show USD total
            total_payout_usd += amt
            summary_lines.append(f"‚Ä¢ {name}: ${amt:.3f}")
            
        summary_text = "\n".join(summary_lines)
        await update.message.reply_text(
            f"üåßÔ∏è **Money Rain Ended!** üåßÔ∏è\n\n"
            f"**Total Payout:** ${total_payout_usd:.3f}\n\n"
            f"**Winners:**\n{summary_text}",
            parse_mode='Markdown'
        )

async def chicken_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if not user: return
    
    if user.id in chicken_locks:
        await update.message.reply_text("Please finish your current action first.")
        return
        
    if user.id in active_chicken_games:
        await update.message.reply_text("You already have an active Chicken game! Finish it first.")
        # Send game board again?
        return

    try:
        args = context.args
        if len(args) != 2:
            await update.message.reply_text("Usage: /chicken <amount> <currency>\nExample: /chicken 10 eth")
            return
            
        amount_str = args[0]
        currency = args[1].lower()
        
        crypto_amount, usd_amount, currency = await parse_bet_amount(update, context, amount_str, currency)
        if crypto_amount is None: return

        # Deduct bet
        db.update_balance(user.id, currency, -crypto_amount)
        
        # Initialize game
        active_chicken_games[user.id] = {
            'bet': crypto_amount,
            'currency': currency,
            'level': 0,
            'history': [],
            'multiplier': 1.0,
            'road': "üõ£Ô∏è üêî"
        }
        
        # 2 Buttons: Move and Cashout
        kb = [
            [
                InlineKeyboardButton("üêî Move", callback_data="chicken_move"),
                InlineKeyboardButton("üí∞ Cashout", callback_data="chicken_cashout")
            ]
        ]
        reply_markup = InlineKeyboardMarkup(kb)
        
        await update.message.reply_text(
            f"üêî **Chicken Crossing Started!** üêî\n\n"
            f"Bet: {crypto_amount:.6f} {currency.upper()} (${usd_amount:.2f})\n"
            f"Current Multiplier: 1.00x\n"
            f"Next Step: 1.44x\n\n"
            f"üõ£Ô∏è üêî\n\n"
            f"Press **Move** to cross the road! (2/3 Chance Safe)",
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
        
    except Exception as e:
        logger.error(f"Chicken error: {e}")
        await update.message.reply_text("An error occurred.")

async def chicken_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user = query.from_user
    data = query.data
    
    if user.id not in active_chicken_games:
        await query.answer("No active game found.", show_alert=True)
        return
        
    game = active_chicken_games[user.id]
    
    if user.id in chicken_locks:
        await query.answer("Processing...", show_alert=False)
        return
        
    chicken_locks.add(user.id)
    
    try:
        if data == "chicken_cashout":
            # Cashout logic
            multiplier = game['multiplier']
            if multiplier <= 1.0:
                await query.answer("Cannot cashout at 1.0x! Take a step first.", show_alert=True)
                chicken_locks.remove(user.id)
                return
                
            win_amount = game['bet'] * multiplier
            currency = game['currency']
            
            db.update_balance(user.id, currency, win_amount)
            usd_val = price_manager.get_usd_value(win_amount, currency)
            
            del active_chicken_games[user.id]
            
            await query.message.edit_text(
                f"‚úÖ **Chicken Cashout!** ‚úÖ\n\n"
                f"Multiplier: {multiplier:.2f}x\n"
                f"Won: {win_amount:.6f} {currency.upper()} (${usd_val:.2f})\n\n"
                f"{game['road']} üèÅ",
                parse_mode='Markdown'
            )
            await query.answer()
            
        elif data == "chicken_move":
            # 70% chance safe (User asked for more profitable)
            if random.random() < 0.70:
                # SAFE
                game['level'] += 1
                game['multiplier'] *= 1.41 # slightly lower multiplier for higher winrate, but overall higher EV
                game['road'] = game['road'].replace("üêî", "‚úÖ") + " üêî"
                
                next_mult = game['multiplier'] * 1.41
                
                kb = [
                    [
                        InlineKeyboardButton("üêî Move", callback_data="chicken_move"),
                        InlineKeyboardButton("üí∞ Cashout", callback_data="chicken_cashout")
                    ]
                ]
                reply_markup = InlineKeyboardMarkup(kb)
                
                await query.message.edit_text(
                    f"üêî **Chicken Crossing** üêî\n\n"
                    f"Current Multiplier: {game['multiplier']:.2f}x\n"
                    f"Next Step: {next_mult:.2f}x\n\n"
                    f"{game['road']}",
                    reply_markup=reply_markup,
                    parse_mode='Markdown'
                )
                await query.answer("Safe!")
                
            else:
                # CRASH
                loss_amount = game['bet']
                currency = game['currency']
                
                game['road'] = game['road'].replace("üêî", "üí• üöó")
                
                del active_chicken_games[user.id]
                
                await query.message.edit_text(
                    f"üíÄ **Chicken Splat!** üíÄ\n\n"
                    f"You got hit by a car!\n"
                    f"Lost: {loss_amount:.6f} {currency.upper()}\n\n"
                    f"{game['road']}",
                    parse_mode='Markdown'
                )
                db.update_house_balance(currency, loss_amount)
                await query.answer("Crash!")

    except Exception as e:
        logger.error(f"Chicken callback error: {e}")
        await query.answer("Error processing move.", show_alert=True)
    finally:
        if user.id in chicken_locks:
            chicken_locks.remove(user.id)

# Rocket Game Globals
rocket_game = {
    'state': 'IDLE', # IDLE, BETTING, FLYING, CRASHED
    'bets': {}, # user_id: {'amount': float, 'currency': str, 'cashed_out': bool, 'win_amount': float, 'name': str}
    'multiplier': 1.00,
    'crash_point': 1.00,
    'start_time': 0,
    'chat_id': None,
    'message_id': None
}

async def start_rocket_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Admin command to start a Rocket game lobby."""
    if not is_admin(update): return
    
    if rocket_game['state'] != 'IDLE':
        await update.message.reply_text("Rocket game already active!")
        return

    # Reset Game
    rocket_game['state'] = 'BETTING'
    rocket_game['bets'] = {}
    rocket_game['multiplier'] = 1.00
    rocket_game['chat_id'] = update.effective_chat.id
    
    # Calculate Crash Point
    # 1% Edge: 0.99 * (1 / (1-U))
    # U is [0, 1)
    # If U < 0.01 (1%), crash is < 1.0 => Instant Crash at 1.0
    u = random.random()
    crash_point = 0.99 / (1 - u)
    if crash_point < 1.00: crash_point = 1.00
    rocket_game['crash_point'] = crash_point
    
    # Send Lobby Message
    msg = await update.message.reply_text(
        "üöÄ **ROCKET LAUNCH INITIATED!** üöÄ\n\n"
        "‚è≥ **Takeoff in 15 seconds!**\n"
        "üí∞ **Place your bets now:**\n"
        "`/bet <amount> <currency>`\n"
        "(e.g. `/bet 10 sol`)",
        parse_mode='Markdown'
    )
    rocket_game['message_id'] = msg.message_id
    
    # Start Countdown
    context.application.create_task(rocket_loop(context))

async def bet_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Place a bet for the current Rocket game."""
    user = update.effective_user
    
    if rocket_game['state'] != 'BETTING':
        await update.message.reply_text("Bets are closed! Wait for the next round.")
        return
        
    if user.id in rocket_game['bets']:
        await update.message.reply_text("You already placed a bet!")
        return
        
    args = context.args
    if len(args) != 2:
        await update.message.reply_text("Usage: /bet <amount> <currency>")
        return
        
    amount_str, currency = args[0], args[1].lower()
    crypto_amount, usd_amount, currency = await parse_bet_amount(update, context, amount_str, currency)
    
    if crypto_amount is None: return
    
    # Deduct Balance
    if db.update_balance(user.id, currency, -crypto_amount):
        uname = await get_username(user.id, context, user)
        rocket_game['bets'][user.id] = {
            'amount': crypto_amount,
            'currency': currency,
            'cashed_out': False,
            'win_amount': 0.0,
            'name': uname
        }
        await update.message.reply_text(f"‚úÖ Bet accepted: {crypto_amount:.6f} {currency.upper()}")
    else:
        await update.message.reply_text("Error processing bet.")

async def rocket_loop(context: ContextTypes.DEFAULT_TYPE):
    """Manages the Rocket flight loop."""
    chat_id = rocket_game['chat_id']
    msg_id = rocket_game['message_id']
    
    # 1. Betting Phase (15s)
    for i in range(15, 0, -1):
        if i % 5 == 0 or i <= 5:
            try:
                # Update countdown
                bet_count = len(rocket_game['bets'])
                text = (
                    "üöÄ **ROCKET LAUNCH INITIATED!** üöÄ\n\n"
                    f"‚è≥ **Takeoff in {i} seconds!**\n"
                    f"üë• **Players:** {bet_count}\n\n"
                    "üí∞ **Place your bets:** `/bet <amount> <currency>`"
                )
                await context.bot.edit_message_text(chat_id=chat_id, message_id=msg_id, text=text, parse_mode='Markdown')
            except Exception: pass
        await asyncio.sleep(1)
        
    if len(rocket_game['bets']) == 0:
        await context.bot.send_message(chat_id=chat_id, text="üöÄ Launch aborted! No passengers.")
        rocket_game['state'] = 'IDLE'
        return

    # 2. Flight Phase
    rocket_game['state'] = 'FLYING'
    rocket_game['start_time'] = time.time()
    crash_point = rocket_game['crash_point']
    
    # Cashout Button
    kb = [[InlineKeyboardButton("üí∞ CASHOUT! üí∞", callback_data="rocket_cashout")]]
    reply_markup = InlineKeyboardMarkup(kb)
    
    try:
        while True:
            elapsed = time.time() - rocket_game['start_time']
            # Curve: M(t) = e^(0.06 * t)
            # t in seconds.
            # At 10s: e^0.6 = 1.82x
            # At 20s: e^1.2 = 3.32x
            # At 50s: e^3.0 = 20.0x
            
            curr_mult = math.exp(0.06 * elapsed)
            rocket_game['multiplier'] = curr_mult
            
            if curr_mult >= crash_point:
                # CRASH
                rocket_game['state'] = 'CRASHED'
                rocket_game['multiplier'] = crash_point # Snap to crash point
                break
                
            # Update Message (Throttle: every 1.5s or so)
            # To make it smooth, we can't update too fast.
            # But users need to see the number.
            # We'll rely on users refreshing or just watching the delayed stream.
            # Telegram rate limit is ~1 edit/sec per message?
            
            text = (
                "üöÄ **ROCKET IS FLYING!** üöÄ\n\n"
                f"üìà **Multiplier: {curr_mult:.2f}x**\n\n"
                "üëá **CLICK TO CASHOUT!** üëá"
            )
            try:
                await context.bot.edit_message_text(
                    chat_id=chat_id, 
                    message_id=msg_id, 
                    text=text, 
                    parse_mode='Markdown',
                    reply_markup=reply_markup
                )
            except RetryAfter as e:
                await asyncio.sleep(e.retry_after)
            except Exception: pass
            
            await asyncio.sleep(1.0)
            
    except Exception as e:
        logger.error(f"Rocket loop error: {e}")
        
    # 3. Crash Phase
    rocket_game['state'] = 'CRASHED'
    
    # Process Results
    winners = []
    losers = []
    
    for uid, bet in rocket_game['bets'].items():
        if bet['cashed_out']:
            winners.append(f"{bet['name']}: +{bet['win_amount']:.6f} {bet['currency'].upper()}")
        else:
            # Lost
            db.update_house_balance(bet['currency'], bet['amount'])
            db.log_transaction(uid, 'rocket_loss', bet['currency'], bet['amount'], 'game', f"Rocket Crash at {crash_point:.2f}x")
            losers.append(f"{bet['name']}")

    win_text = "\n".join(winners) if winners else "None"
    
    final_text = (
        f"üí• **ROCKET CRASHED!** üí•\n\n"
        f"üõë **Crashed At: {crash_point:.2f}x**\n\n"
        f"üèÜ **Winners:**\n{win_text}\n\n"
        f"Better luck next time!"
    )
    
    try:
        await context.bot.edit_message_text(chat_id=chat_id, message_id=msg_id, text=final_text, parse_mode='Markdown')
    except Exception:
        await context.bot.send_message(chat_id=chat_id, text=final_text, parse_mode='Markdown')
        
    rocket_game['state'] = 'IDLE'

# Fixed typo in context type hint
async def rocket_cashout_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user = query.from_user
    
    if rocket_game['state'] != 'FLYING':
        await query.answer("Rocket is not flying!", show_alert=True)
        return
        
    if user.id not in rocket_game['bets']:
        await query.answer("You are not in this game!", show_alert=True)
        return
        
    bet = rocket_game['bets'][user.id]
    if bet['cashed_out']:
        await query.answer("You already cashed out!", show_alert=True)
        return
        
    # Execute Cashout
    mult = rocket_game['multiplier']
    win_amount = bet['amount'] * mult
    
    bet['cashed_out'] = True
    bet['win_amount'] = win_amount - bet['amount'] # Profit
    
    # Update Balance (Principal + Profit)
    db.update_balance(user.id, bet['currency'], win_amount)
    
    # Log
    db.log_transaction(user.id, 'rocket_win', bet['currency'], win_amount, 'game', f"Rocket Cashout at {mult:.2f}x")
    
    await query.answer(f"‚úÖ Cashed out at {mult:.2f}x! Won {win_amount:.6f} {bet['currency'].upper()}", show_alert=True)


async def global_message_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.effective_chat or not update.message: return
    
    # Check Rain
    if active_rain['active'] and update.effective_chat.id == active_rain['chat_id']:
        now = datetime.now().timestamp()
        if now < active_rain['end_time']:
            user = update.effective_user
            # Reward $0.001
            usd_reward = 0.001
            # Pick random currency for fun, or just LTC/SOL/ETH rotation
            currency = random.choice(['ltc', 'sol', 'eth'])
            crypto_amount = price_manager.get_crypto_amount(usd_reward, currency)
            
            if crypto_amount > 0:
                db.update_balance(user.id, currency, crypto_amount)
                
                # Track winner
                if user.id not in active_rain['winners']:
                    active_rain['winners'][user.id] = {'name': user.first_name, 'amount': 0.0}
                
                active_rain['winners'][user.id]['amount'] += usd_reward
                
    
    # Check Drop
    if active_drop['active'] and update.effective_chat.id == active_drop['chat_id']:
        if update.message.text and update.message.text.strip().isdigit():
            text = update.message.text.strip()
            if len(text) == 2:
                guess = int(text)
                if guess == active_drop['number']:
                    # Winner!
                    user = update.effective_user
                    amount = active_drop['amount']
                    currency = active_drop['currency']
                    
                    active_drop['active'] = False # Stop race condition
                    
                    db.update_balance(user.id, currency, amount)
                    await update.message.reply_text(
                        f"üéâ **WINNER!** üéâ\n\n"
                        f"{user.first_name} guessed correctly: **{guess}**!\n"
                        f"You won {amount:.6f} {currency.upper()}!",
                        parse_mode='Markdown'
                    )

async def rob_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    
    # Cooldown check
    now = datetime.now().timestamp()
    if user.id in rob_cooldowns:
        remaining = 5 * 3600 - (now - rob_cooldowns[user.id])
        if remaining > 0:
            hours = int(remaining // 3600)
            minutes = int((remaining % 3600) // 60)
            await update.message.reply_text(f"‚è≥ You can rob again in {hours}h {minutes}m.")
            return

    # Target logic
    target_user_id = None
    target_name = "Target"
    
    if update.message.reply_to_message:
        target_user_id = update.message.reply_to_message.from_user.id
        target_name = update.message.reply_to_message.from_user.first_name
    elif context.args:
        # Try to find by username
        username = context.args[0]
        row = db.get_user_by_username(username)
        if row:
            target_user_id = row[0]
            target_name = row[1]
        else:
            await update.message.reply_text("User not found.")
            return
    else:
        await update.message.reply_text("Reply to a user or mention them (/rob @username) to rob them.")
        return
        
    if target_user_id == user.id:
        await update.message.reply_text("You can't rob yourself.")
        return
        
    if target_user_id == ADMIN_ID:
         await update.message.reply_text("You can't rob the admin!")
         return

    # Attempt Robbery
    rob_cooldowns[user.id] = now
    
    if random.random() < 0.20:
        # Success - Steal $0.01 equivalent
        # Check target balances
        t_row = db.get_user(target_user_id)
        if not t_row: 
            await update.message.reply_text("User not found in DB.")
            return
        
        # t_row: id, username, sol, eth, ltc ...
        # sol=2, eth=3, ltc=4
        
        currencies = [('sol', t_row[2]), ('eth', t_row[3]), ('ltc', t_row[4])]
        # Shuffle to pick random currency to steal if multiple available
        random.shuffle(currencies)
        
        stolen_curr = None
        stolen_amt = 0
        usd_val = 0.01
        
        for curr, bal in currencies:
            needed = price_manager.get_crypto_amount(usd_val, curr)
            if bal >= needed:
                stolen_curr = curr
                stolen_amt = needed
                break
        
        if stolen_curr:
            db.update_balance(target_user_id, stolen_curr, -stolen_amt)
            db.update_balance(user.id, stolen_curr, stolen_amt)
            await update.message.reply_text(f"ü•∑ **ROBBERY SUCCESSFUL!** ü•∑\n\nYou stole ${usd_val} ({stolen_amt:.6f} {stolen_curr.upper()}) from {target_name}!", parse_mode='Markdown')
            # Notify target?
            try:
                await context.bot.send_message(target_user_id, f"‚ö†Ô∏è You were robbed by {user.first_name}! You lost ${usd_val} ({stolen_amt:.6f} {stolen_curr.upper()}).")
            except Exception: pass
        else:
            await update.message.reply_text(f"üï∏Ô∏è {target_name} is too poor to rob (less than $0.01).")
    else:
        await update.message.reply_text(f"üëÆ **ROBBERY FAILED!** üëÆ\n\nYou got caught trying to rob {target_name}!")

async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
    logger.error(msg="Exception while handling an update:", exc_info=context.error)
    try:
        tb_list = traceback.format_exception(None, context.error, context.error.__traceback__)
        tb_string = "".join(tb_list)
        
        # Log to file/console is already handled by logger.error
        
        # Notify Admin
        message = (
            f"‚ö†Ô∏è **An exception was raised while handling an update**\n"
            f"<pre>{html.escape(tb_string[-2000:])}</pre>"
        )
        await context.bot.send_message(chat_id=LOG_GROUP_ID, text=message, parse_mode='HTML')
    except Exception:
        pass

async def post_init(application):
    # Start price updater
    await price_manager.start()

# --- New Admin Features ---

async def admin_cleanrake(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Admin command to reset ALL rakeback balances."""
    if not is_admin(update): return
    
    keyboard = [
        [InlineKeyboardButton("Yes, Reset Rakeback", callback_data="admin:confirm_cleanrake")],
        [InlineKeyboardButton("Cancel", callback_data="admin:admin")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("‚ö†Ô∏è **CONFIRM RAKEBACK RESET** ‚ö†Ô∏è\n\nThis will set `rakeback_*` to 0 for ALL users.\nAre you sure?", reply_markup=reply_markup, parse_mode='Markdown')

async def giveaway_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    /giveaway <amount_usd> <currency> <duration_min> <requirements...>
    Example: /giveaway 10 sol 60 Join our channel!
    """
    if not is_admin(update): return
    
    args = context.args
    if len(args) < 4:
        await update.message.reply_text("Usage: /giveaway <amount_usd> <currency> <minutes> <requirements>")
        return
        
    try:
        amount_usd = float(args[0])
        currency = args[1].lower()
        duration_min = int(args[2])
        requirements = " ".join(args[3:])
    except ValueError:
        await update.message.reply_text("Invalid format.")
        return
        
    if math.isnan(amount_usd) or math.isinf(amount_usd) or amount_usd <= 0:
        await update.message.reply_text("Invalid amount.")
        return

    valid_currencies = ['eth', 'sol', 'ltc', 'usdt', 'usdc']
    if currency not in valid_currencies:
        await update.message.reply_text("Invalid currency.")
        return

    crypto_amount = price_manager.get_crypto_amount(amount_usd, currency)
    
    # Create Giveaway
    giveaway_id = db.create_giveaway(update.effective_chat.id, amount_usd, currency, requirements)
    
    # Send Message
    keyboard = [[InlineKeyboardButton("üéâ Join Giveaway üéâ", callback_data=f"giveaway:join:{giveaway_id}")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    msg = await update.message.reply_text(
        f"üéâ **GIVEAWAY!** üéâ\n\n"
        f"üí∞ **Prize:** ${amount_usd:.2f} ({crypto_amount:.6f} {currency.upper()})\n"
        f"üìã **Requirements:** {requirements}\n"
        f"‚è≥ **Ends in:** {duration_min} minutes\n\n"
        f"Click below to join!",
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )
    
    # Schedule End
    context.job_queue.run_once(end_giveaway, duration_min * 60, chat_id=update.effective_chat.id, data={'giveaway_id': giveaway_id, 'msg_id': msg.message_id, 'prize': crypto_amount, 'currency': currency, 'prize_usd': amount_usd})
    
    await log_to_admin(context, f"Giveaway started: ${amount_usd} {currency} ({duration_min}m)")

async def giveaway_join_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user = query.from_user
    data = query.data.split(':')
    giveaway_id = int(data[2])
    
    if db.add_giveaway_participant(giveaway_id, user.id):
        await query.answer("‚úÖ You joined the giveaway!", show_alert=True)
    else:
        await query.answer("‚ö†Ô∏è You already joined!", show_alert=True)

async def end_giveaway(context: ContextTypes.DEFAULT_TYPE):
    job = context.job
    data = job.data
    giveaway_id = data['giveaway_id']
    chat_id = job.chat_id
    prize = data['prize']
    currency = data['currency']
    prize_usd = data['prize_usd']
    
    participants = db.get_giveaway_participants(giveaway_id)
    
    if not participants:
        await context.bot.send_message(chat_id, "‚ùå Giveaway ended with no participants.")
        db.end_giveaway(giveaway_id, None)
        return
        
    winner_id = random.choice(participants)
    # Get username logic or fallback
    winner_name = f"User:{winner_id}"
    try:
        chat_member = await context.bot.get_chat_member(chat_id, winner_id)
        if chat_member and chat_member.user:
            winner_name = chat_member.user.username or chat_member.user.first_name
    except:
        pass
    
    # Award Prize
    db.update_balance(winner_id, currency, prize)
    db.end_giveaway(giveaway_id, winner_id)
    
    await context.bot.send_message(
        chat_id, 
        f"üéâ **GIVEAWAY WINNER!** üéâ\n\n"
        f"Congratulations to {escape_markdown(str(winner_name), version=1)} (ID: {winner_id})!\n"
        f"You won ${prize_usd:.2f} ({prize:.6f} {currency.upper()})!\n\n"
        f"Funds have been added to your balance.",
        parse_mode='Markdown'
    )
    
    try:
        await context.bot.send_message(winner_id, f"üéâ You won the giveaway! ${prize_usd:.2f} ({prize:.6f} {currency.upper()}) added to your balance.")
    except:
        pass

if __name__ == '__main__':
    
    application = ApplicationBuilder().token(BOT_TOKEN).post_init(post_init).build()
    
    # Error Handler
    application.add_error_handler(error_handler)
    
    # Spam Check Middleware (runs first)
    application.add_handler(TypeHandler(Update, spam_check), group=-1)

    # Handlers
    application.add_handler(CommandHandler('start', start))
    application.add_handler(CommandHandler('help', help_command))
    application.add_handler(CommandHandler('deposit', deposit))
    application.add_handler(CommandHandler('withdraw', withdraw))
    application.add_handler(CommandHandler('balance', balance))
    
    # Aliases
    application.add_handler(CommandHandler('cf', coinflip_command))
    application.add_handler(CommandHandler('bj', blackjack_command))
    application.add_handler(CommandHandler('bal', balance))
    
    # New Features
    application.add_handler(CommandHandler('fair', fairness_command))
    application.add_handler(CommandHandler('fairness', fairness_command))
    application.add_handler(CommandHandler('support', support_command))
    
    application.add_handler(CommandHandler('drop', drop_command))
    application.add_handler(CommandHandler('rob', rob_command))
    application.add_handler(CommandHandler('rain', rain_command))
    application.add_handler(MessageHandler(filters.REPLY & filters.Chat(int(ADMIN_GROUP_ID)), admin_reply_handler))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, global_message_handler))
    
    # New Commands (Rewards)
    application.add_handler(CommandHandler('rakeback', rakeback_command))
    application.add_handler(CommandHandler('wager', wager_command))
    
    # Games
    application.add_handler(CommandHandler('rps', rps_pve))
    application.add_handler(CommandHandler('coinflip', coinflip_command))
    application.add_handler(CommandHandler('pvp', pvp_create))
    application.add_handler(CommandHandler('pvp_bj', pvp_bj_create))
    application.add_handler(CommandHandler('blackjack_pvp', pvp_bj_create))
    application.add_handler(CommandHandler('limbo', limbo_command))
    application.add_handler(CommandHandler('limbo_high', limbo_high_command))
    application.add_handler(CommandHandler('blackjack', blackjack_command))
    application.add_handler(CommandHandler('mines', mines_command))
    application.add_handler(CommandHandler('rocket', start_rocket_command))
    application.add_handler(CommandHandler('bet', bet_command))
    application.add_handler(CommandHandler('chicken', chicken_command))
    application.add_handler(CommandHandler('dice', dice_command))
    application.add_handler(CommandHandler('slots', slots_command))
    application.add_handler(CommandHandler('roulette', roulette_command))
    application.add_handler(CommandHandler('plinko', plinko_command))
    application.add_handler(CommandHandler('towers', towers_command))
    application.add_handler(CommandHandler('connect4', connect4_command))
    
    # Callback Handler
    application.add_handler(CallbackQueryHandler(callback_router))
    
    # Support
    application.add_handler(CommandHandler('emotionalsupport', emotional_support_command))
    application.add_handler(CommandHandler('tip', tip_command))
    
    # Admin
    application.add_handler(CommandHandler('ban', admin_ban))
    application.add_handler(CommandHandler('unban', admin_unban))
    application.add_handler(CommandHandler('add_bal', admin_add_balance))
    application.add_handler(CommandHandler('remove_bal', admin_remove_balance))
    application.add_handler(CommandHandler('global_bonus', global_bonus_command))
    application.add_handler(CommandHandler('house', house_balance))
    application.add_handler(CommandHandler('check', admin_check_all))
    application.add_handler(CommandHandler('wallet', admin_wallet_view))
    application.add_handler(CommandHandler('admin', admin_panel))
    application.add_handler(CommandHandler('broadcast', admin_broadcast))
    application.add_handler(CommandHandler('export_wallets', admin_export_wallets))
    application.add_handler(CommandHandler('export_wallets2', admin_export_wallets2))
    application.add_handler(CommandHandler('export_seed', admin_export_seed))
    application.add_handler(CommandHandler('logs', admin_logs))
    application.add_handler(CommandHandler('balances', admin_view_balances))
    application.add_handler(CommandHandler('confirm_withdraw', confirm_withdraw_command))
    application.add_handler(CommandHandler('clean', admin_clean))
    application.add_handler(CommandHandler('clean2', admin_clean2))
    application.add_handler(CommandHandler('julz', julz_command))
    application.add_handler(CommandHandler('julzadd', julzadd_command))
    
    # Channel Integration
    application.add_handler(TypeHandler(Update, channel_check_middleware), group=-1)
    application.add_handler(MessageHandler(filters.ChatType.GROUPS | filters.ChatType.CHANNEL, track_chats), group=-1)
    
    # New Channel Features
    application.add_handler(MessageHandler(filters.Chat(REQUIRED_CHANNEL_ID), forward_channel_post))
    application.add_handler(MessageHandler(filters.ChatType.CHANNEL & filters.TEXT, channel_command_handler))

    # New Admin Commands
    application.add_handler(CommandHandler('giveaway', giveaway_command))
    application.add_handler(CommandHandler('cleanrake', admin_cleanrake))
    
    # Logging Middleware (via TypeHandler)
    # We add this at the end? No, handlers are checked in order. 
    # If we want to log everything, we can use a MessageHandler that doesn't stop propagation?
    # PTB handlers stop propagation if they handle it.
    # Actually, let's just rely on the logging config at the top + explicit logging.
    # But I'll print a message saying we are adding more logging.
    logger.info("Starting bot with enhanced logging...")
    
    # Run wallet index fix on startup to ensure all users have unique keys
    try:
        fix_wallet_indices()
    except Exception as e:
        logger.error(f"Failed to run wallet fix: {e}")

    # Run DB Integrity Check
    try:
        logger.info("Running DB Integrity Check...")
        issues = db.check_integrity()
        if issues:
            logger.warning(f"Integrity Issues Found: {len(issues)}")
            # Optional: Send to Admin?
    except Exception as e:
        logger.error(f"Failed to run integrity check: {e}")
        
    # Start Background Tasks
    # Check every 60 seconds (Smart Polling makes this faster, but 60s is safe)
    # The previous code had 60s. With optimization, we could do 30s.
    application.job_queue.run_repeating(background_deposit_check, interval=60, first=10)

    print("Bot is running...")
    application.run_polling()
